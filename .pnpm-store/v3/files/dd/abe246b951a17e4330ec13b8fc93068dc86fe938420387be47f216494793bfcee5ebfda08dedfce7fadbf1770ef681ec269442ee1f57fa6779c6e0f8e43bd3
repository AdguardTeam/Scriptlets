{"version":3,"file":"skip-regex.js","sources":["../src/skip-regex.js"],"sourcesContent":["/**\n * @exports skipRegex\n */\nexport default (function () {\n\n  // Safe characters that may precede a regex (including `=>` and `**`)\n  const beforeReChars = '[{(,;:?=|&!^~<>%*/'\n  const beforeReSign = beforeReChars + '+-'\n\n  // Keyword that can may precede a regex\n  const beforeReWords = [\n    'await',\n    'case',\n    'default',\n    'do',\n    'else',\n    'extends',\n    'in',\n    'instanceof',\n    'of',\n    'prefix',\n    'return',\n    'typeof',\n    'void',\n    'yield',\n  ]\n\n  // Last chars of all the beforeReWords elements to speed up the process.\n  const wordsEndChar = beforeReWords.reduce((s, w) => s + w.slice(-1), '')\n\n  // Matches literal regex from the start of the buffer.\n  // The buffer to search must not include line-endings.\n  const R_JS_REGEX = /^\\/(?=[^*/])[^[/\\\\]*(?:(?:\\\\.|\\[(?:\\\\.|[^\\]\\\\]*)*\\])[^[\\\\/]*)*?\\/[gimuys]*/\n\n  // Valid characters for JavaScript variable names and literal numbers.\n  const R_JS_VCHAR = /[$\\w]/\n\n  // Matches all up to the end of line.\n  const R_LINE_ALL = /.*/g\n\n  /**\n   * Searches the position of the previous non-blank character inside `code`\n   * starting at `pos - 1`.\n   *\n   * @param   {string} code - Buffer to search\n   * @param   {number} pos  - Starting position\n   * @returns {number} Position of the first non-blank character to the left.\n   * @private\n   */\n  const _prev = function (code, pos) {\n    while (--pos >= 0 && /\\s/.test(code[pos])) {}\n    return pos\n  }\n\n  /**\n   * Checks if the character at the `start` position within `code` can be\n   * a regular expression and returns the ending position of this regex, or\n   * `start+1` if it not.\n   *\n   * NOTE: Ensure `start` points to a slash (this is not checked).\n   *\n   * @param {string} code Text buffer\n   * @param {number} start Position of the a slash within `code`\n   * @returns {number} Position of the chararacter following the regex.\n   */\n  return function skipRegex (code, start) {\n\n    // `re.exec()` will extract from the slash to the end of the line\n    const re = R_LINE_ALL\n    let pos = re.lastIndex = start++\n    let match = re.exec(code)\n\n    // and this `match()` will match the possible regex.\n    match = match && match[0].match(R_JS_REGEX)\n\n    if (match) {\n      // Stores the ending position of this prossible regex.\n      const next = pos + match[0].length\n\n      pos = _prev(code, pos)\n      let c = code[pos]\n\n      // start of buffer or safe prefix?\n      if (pos < 0 || ~beforeReChars.indexOf(c)) {\n        return next\n      }\n\n      // from here, `pos` is >= 0 and `c` is the non-blank character\n      // preceding the slash.\n\n      if (c === '.') {\n        // can be `...` or something silly like 5./2\n        if (code[pos - 1] === '.') {\n          start = next\n        }\n\n      } else {\n\n        if (c === '+' || c === '-') {\n          // tricky case\n          if (code[--pos] !== c ||            // if have a single operator or\n             (pos = _prev(code, pos)) < 0) {  // ...have `++` and no previous token\n            return next                       // ...this is a regex\n          }\n\n          // we have '++' and `pos` points to the preceding non-blank\n          c = code[pos]\n          if (~beforeReSign.indexOf(c)) {\n            return next                       // ...this is a regex\n          }\n        }\n\n        if (~wordsEndChar.indexOf(c)) {  // looks like a keyword?\n          const end = pos + 1\n\n          // get the complete (previous) keyword\n          while (--pos >= 0 && R_JS_VCHAR.test(code[pos])) {}\n\n          // it is in the allowed keywords list?\n          if (~beforeReWords.indexOf(code.slice(pos + 1, end))) {\n            start = next\n          }\n        }\n      }\n    }\n\n    return start\n  }\n\n})()\n"],"names":["const","let"],"mappings":";;;;;;;;AAGA,gBAAe,CAAC,YAAY;EAG1BA,IAAM,aAAa,GAAG,qBAAoB;EAC1CA,IAAM,YAAY,GAAG,aAAa,GAAG,KAAI;EAGzCA,IAAM,aAAa,GAAG;IACpB,OAAO;IACP,MAAM;IACN,SAAS;IACT,IAAI;IACJ,MAAM;IACN,SAAS;IACT,IAAI;IACJ,YAAY;IACZ,IAAI;IACJ,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,MAAM;IACN,OAAO,GACR;EAGDA,IAAM,YAAY,GAAG,aAAa,CAAC,MAAM,WAAE,CAAC,EAAE,CAAC,EAAE,SAAG,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,IAAC,EAAE,EAAE,EAAC;EAIxEA,IAAM,UAAU,GAAG,6EAA4E;EAG/FA,IAAM,UAAU,GAAG,QAAO;EAG1BA,IAAM,UAAU,GAAG,MAAK;EAWxBA,IAAM,KAAK,GAAG,UAAU,IAAI,EAAE,GAAG,EAAE;IACjC,OAAO,EAAE,GAAG,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,EAAE;IAC7C,OAAO,GAAG;IACX;EAaD,OAAO,SAAS,SAAS,EAAE,IAAI,EAAE,KAAK,EAAE;IAGtCA,IAAM,EAAE,GAAG,WAAU;IACrBC,IAAI,GAAG,GAAG,EAAE,CAAC,SAAS,GAAG,KAAK,GAAE;IAChCA,IAAI,KAAK,GAAG,EAAE,CAAC,IAAI,CAAC,IAAI,EAAC;IAGzB,KAAK,GAAG,KAAK,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,UAAU,EAAC;IAE3C,IAAI,KAAK,EAAE;MAETD,IAAM,IAAI,GAAG,GAAG,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,OAAM;MAElC,GAAG,GAAG,KAAK,CAAC,IAAI,EAAE,GAAG,EAAC;MACtBC,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,EAAC;MAGjB,IAAI,GAAG,GAAG,CAAC,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE;QACxC,OAAO,IAAI;OACZ;MAKD,IAAI,CAAC,KAAK,GAAG,EAAE;QAEb,IAAI,IAAI,CAAC,GAAG,GAAG,CAAC,CAAC,KAAK,GAAG,EAAE;UACzB,KAAK,GAAG,KAAI;SACb;OAEF,MAAM;QAEL,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,GAAG,EAAE;UAE1B,IAAI,IAAI,CAAC,EAAE,GAAG,CAAC,KAAK,CAAC;aAClB,CAAC,GAAG,GAAG,KAAK,CAAC,IAAI,EAAE,GAAG,CAAC,IAAI,CAAC,EAAE;YAC/B,OAAO,IAAI;WACZ;UAGD,CAAC,GAAG,IAAI,CAAC,GAAG,EAAC;UACb,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE;YAC5B,OAAO,IAAI;WACZ;SACF;QAED,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE;UAC5BD,IAAM,GAAG,GAAG,GAAG,GAAG,EAAC;UAGnB,OAAO,EAAE,GAAG,IAAI,CAAC,IAAI,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,EAAE;UAGnD,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE;YACpD,KAAK,GAAG,KAAI;WACb;SACF;OACF;KACF;IAED,OAAO,KAAK;GACb;CAEF,GAAG;;;;"}