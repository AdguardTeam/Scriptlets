/*
 * AGTree v3.0.0-alpha.1 (build date: Tue, 12 Nov 2024 16:11:58 GMT)
 * (c) 2024 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
'use strict';

var adblockers = require('../../utils/adblockers.js');
var constants = require('../../utils/constants.js');
var baseGenerator = require('../base-generator.js');
var cosmeticRulePatternGenerator = require('./cosmetic-rule-pattern-generator.js');
var cosmeticRuleBodyGenerator = require('./cosmetic-rule-body-generator.js');

/**
 * `CosmeticRuleParser` is responsible for parsing cosmetic rules.
 *
 * Where possible, it automatically detects the difference between supported syntaxes:
 *  - AdGuard
 *  - uBlock Origin
 *  - Adblock Plus
 *
 * If the syntax is common / cannot be determined, the parser gives `Common` syntax.
 *
 * Please note that syntactically correct rules are parsed even if they are not actually
 * compatible with the given adblocker. This is a completely natural behavior, meaningful
 * checking of compatibility is not done at the parser level.
 */
// TODO: Make raw body parsing optional
// TODO: Split into smaller sections
class CosmeticRuleGenerator extends baseGenerator.BaseGenerator {
    /**
     * Converts a cosmetic rule AST into a string.
     *
     * @param node Cosmetic rule AST
     * @returns Raw string
     */
    static generate(node) {
        let result = constants.EMPTY;
        // Pattern
        result += cosmeticRulePatternGenerator.CosmeticRulePatternGenerator.generate(node);
        // Separator
        result += node.separator.value;
        // uBO rule modifiers
        if (node.syntax === adblockers.AdblockSyntax.Ubo && node.modifiers) {
            node.modifiers.children.forEach((modifier) => {
                result += constants.COLON;
                result += modifier.name.value;
                if (modifier.value) {
                    result += constants.OPEN_PARENTHESIS;
                    result += modifier.value.value;
                    result += constants.CLOSE_PARENTHESIS;
                }
            });
            // If there are at least one modifier, add a space
            if (node.modifiers.children.length) {
                result += constants.SPACE;
            }
        }
        // Body
        result += cosmeticRuleBodyGenerator.CosmeticRuleBodyGenerator.generate(node);
        return result;
    }
}

exports.CosmeticRuleGenerator = CosmeticRuleGenerator;
