/*
 * AGTree v3.0.0-alpha.1 (build date: Tue, 12 Nov 2024 16:11:58 GMT)
 * (c) 2024 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
'use strict';

var adblockers = require('../../utils/adblockers.js');
var cosmeticRuleSeparator = require('../../utils/cosmetic-rule-separator.js');
var string = require('../../utils/string.js');
var index = require('../../nodes/index.js');
var baseParser = require('../base-parser.js');
var valueParser = require('../misc/value-parser.js');
var options = require('../options.js');

/**
 * `SimpleCommentParser` is responsible for parsing simple comments.
 * Some comments have a special meaning in adblock syntax, like agent comments or hints,
 * but this parser is only responsible for parsing regular comments,
 * whose only purpose is to provide some human-readable information.
 *
 * @example
 * ```adblock
 * ! This is a simple comment
 * # This is a simple comment, but in host-like syntax
 * ```
 */
class SimpleCommentParser extends baseParser.BaseParser {
    /**
     * Checks if the raw rule is a simple comment.
     *
     * @param raw Raw input to check.
     * @returns `true` if the input is a simple comment, `false` otherwise.
     * @note This method does not check for adblock agent comments.
     */
    static isSimpleComment(raw) {
        const trimmed = raw.trim();
        // Exclamation mark based comments
        if (trimmed.startsWith(index.CommentMarker.Regular)) {
            return true;
        }
        // Hashmark based comments
        // Note: in this case, we must be sure that we do not mistakenly parse a cosmetic rule as a #-like comment,
        // since most cosmetic rule separators also start with #
        if (trimmed.startsWith(index.CommentMarker.Hashmark)) {
            const result = cosmeticRuleSeparator.CosmeticRuleSeparatorUtils.find(trimmed);
            // If we cannot find a separator, it means that the rule is definitely a comment
            if (result === null) {
                return true;
            }
            // Otherwise, we must check if the separator is followed by a valid selector
            const { end } = result;
            // No valid selector
            if (!trimmed[end + 1]
                || string.StringUtils.isWhitespace(trimmed[end + 1])
                || (trimmed[end + 1] === index.CommentMarker.Hashmark && trimmed[end + 2] === index.CommentMarker.Hashmark)) {
                return true;
            }
        }
        return false;
    }
    /**
     * Parses a raw rule as a simple comment.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Comment rule node or null (if the raw rule cannot be parsed as a simple comment).
     */
    static parse(raw, options$1 = options.defaultParserOptions, baseOffset = 0) {
        // Ignore non-comment rules
        if (!this.isSimpleComment(raw)) {
            return null;
        }
        // If we are here, it means that the rule is a regular comment
        let offset = 0;
        // Skip leading whitespace (if any)
        offset = string.StringUtils.skipWS(raw, offset);
        // Get comment marker
        const marker = valueParser.ValueParser.parse(raw[offset], options$1, baseOffset + offset);
        // Skip marker
        offset += 1;
        // Get comment text
        const text = valueParser.ValueParser.parse(raw.slice(offset), options$1, baseOffset + offset);
        // Regular comment rule
        const result = {
            category: index.RuleCategory.Comment,
            type: index.CommentRuleType.CommentRule,
            // TODO: Change syntax when hashmark is used
            syntax: adblockers.AdblockSyntax.Common,
            marker,
            text,
        };
        if (options$1.includeRaws) {
            result.raws = {
                text: raw,
            };
        }
        if (options$1.isLocIncluded) {
            result.start = baseOffset;
            result.end = baseOffset + raw.length;
        }
        return result;
    }
}

exports.SimpleCommentParser = SimpleCommentParser;
