/*
 * AGTree v3.0.0-alpha.1 (build date: Tue, 12 Nov 2024 16:11:58 GMT)
 * (c) 2024 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
'use strict';

var string = require('../../utils/string.js');
var constants = require('../../utils/constants.js');
var options = require('../options.js');
var baseParser = require('../base-parser.js');
var valueParser = require('./value-parser.js');

class ParameterListParser extends baseParser.BaseParser {
    /**
     * Parses a raw parameter list.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @param separator Separator character (default: comma)
     * @returns Parameter list AST
     */
    static parse(raw, options$1 = options.defaultParserOptions, baseOffset = 0, separator = constants.COMMA) {
        // Prepare the parameter list node
        const params = {
            type: 'ParameterList',
            children: [],
        };
        const { length } = raw;
        if (options$1.isLocIncluded) {
            params.start = baseOffset;
            params.end = baseOffset + length;
        }
        let offset = 0;
        // Parse parameters: skip whitespace before and after each parameter, and
        // split parameters by the separator character.
        while (offset < length) {
            // Skip whitespace before parameter
            offset = string.StringUtils.skipWS(raw, offset);
            // Parameter may only contain whitespace
            // In this case, we reached the end of the parameter list
            if (raw[offset] === separator || offset === length) {
                // Add a null for empty parameter
                params.children.push(null);
                // Skip separator
                offset += 1;
            }
            else {
                // Get parameter start position
                const paramStart = offset;
                // Get next unescaped separator position
                const nextSeparator = string.StringUtils.findUnescapedNonStringNonRegexChar(raw, separator, offset);
                // Get parameter end position
                const paramEnd = nextSeparator !== -1
                    ? string.StringUtils.skipWSBack(raw, nextSeparator - 1)
                    : string.StringUtils.skipWSBack(raw);
                // Add parameter to the list
                const param = valueParser.ValueParser.parse(raw.slice(paramStart, paramEnd + 1), options$1, baseOffset + paramStart);
                params.children.push(param);
                // Set offset to the next separator position + 1
                offset = nextSeparator !== -1 ? nextSeparator + 1 : length;
            }
        }
        // If the last character was a separator, add an additional null parameter
        if (raw[length - 1] === separator) {
            params.children.push(null);
        }
        return params;
    }
}

exports.ParameterListParser = ParameterListParser;
