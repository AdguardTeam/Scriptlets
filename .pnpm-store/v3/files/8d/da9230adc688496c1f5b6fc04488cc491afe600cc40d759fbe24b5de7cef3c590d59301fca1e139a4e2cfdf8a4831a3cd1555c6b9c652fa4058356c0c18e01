/*
 * AGTree v3.0.0-alpha.1 (build date: Tue, 12 Nov 2024 16:11:58 GMT)
 * (c) 2024 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
'use strict';

var constants = require('../../utils/constants.js');
var string = require('../../utils/string.js');
var index = require('../../nodes/index.js');
var agentParser = require('./agent-parser.js');
var adblockSyntaxError = require('../../errors/adblock-syntax-error.js');
var adblockers = require('../../utils/adblockers.js');
var cosmeticRuleSeparator = require('../../utils/cosmetic-rule-separator.js');
var baseParser = require('../base-parser.js');
var options = require('../options.js');
var typeGuards = require('../../utils/type-guards.js');

/**
 * `AgentParser` is responsible for parsing an Adblock agent rules.
 * Adblock agent comment marks that the filter list is supposed to
 * be used by the specified ad blockers.
 *
 * @example
 *  - ```adblock
 *    [AdGuard]
 *    ```
 *  - ```adblock
 *    [Adblock Plus 2.0]
 *    ```
 *  - ```adblock
 *    [uBlock Origin]
 *    ```
 *  - ```adblock
 *    [uBlock Origin 1.45.3]
 *    ```
 *  - ```adblock
 *    [Adblock Plus 2.0; AdGuard]
 *    ```
 */
class AgentCommentParser extends baseParser.BaseParser {
    /**
     * Checks if the raw rule is an adblock agent comment.
     *
     * @param raw Raw rule
     * @returns `true` if the rule is an adblock agent, `false` otherwise
     */
    static isAgentRule(raw) {
        const rawTrimmed = raw.trim();
        if (rawTrimmed.startsWith(constants.OPEN_SQUARE_BRACKET) && rawTrimmed.endsWith(constants.CLOSE_SQUARE_BRACKET)) {
            // Avoid this case: [$adg-modifier]##[class^="adg-"]
            return typeGuards.isNull(cosmeticRuleSeparator.CosmeticRuleSeparatorUtils.find(rawTrimmed));
        }
        return false;
    }
    /**
     * Parses a raw rule as an adblock agent comment.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Agent rule AST or null (if the raw rule cannot be parsed as an adblock agent comment)
     */
    static parse(raw, options$1 = options.defaultParserOptions, baseOffset = 0) {
        // Ignore non-agent rules
        if (!AgentCommentParser.isAgentRule(raw)) {
            return null;
        }
        let offset = 0;
        // Skip whitespace characters before the rule
        offset = string.StringUtils.skipWS(raw, offset);
        // Skip opening bracket
        offset += 1;
        // last character should be a closing bracket
        const closingBracketIndex = string.StringUtils.skipWSBack(raw, raw.length - 1);
        if (closingBracketIndex === -1 || raw[closingBracketIndex] !== constants.CLOSE_SQUARE_BRACKET) {
            throw new adblockSyntaxError.AdblockSyntaxError('Missing closing bracket', offset, offset + raw.length);
        }
        // Initialize the agent list
        const result = {
            type: index.CommentRuleType.AgentCommentRule,
            syntax: adblockers.AdblockSyntax.Common,
            category: index.RuleCategory.Comment,
            children: [],
        };
        if (options$1.includeRaws) {
            result.raws = {
                text: raw,
            };
        }
        if (options$1.isLocIncluded) {
            result.start = baseOffset;
            result.end = baseOffset + raw.length;
        }
        while (offset < closingBracketIndex) {
            // Skip whitespace characters before the agent
            offset = string.StringUtils.skipWS(raw, offset);
            // Find the separator or the closing bracket
            let separatorIndex = raw.indexOf(constants.SEMICOLON, offset);
            if (separatorIndex === -1) {
                separatorIndex = closingBracketIndex;
            }
            // Find the last non-whitespace character of the agent
            // [AdGuard  ; Adblock Plus 2.0]
            //        ^
            // (if we have spaces between the agent name and the separator)
            const agentEndIndex = string.StringUtils.findLastNonWhitespaceCharacter(raw.slice(offset, separatorIndex)) + offset + 1;
            // Collect the agent
            result.children.push(agentParser.AgentParser.parse(raw.slice(offset, agentEndIndex), options$1, baseOffset + offset));
            // Set the offset to the next agent or the end of the rule
            offset = separatorIndex + 1;
        }
        if (result.children.length === 0) {
            throw new adblockSyntaxError.AdblockSyntaxError('Empty agent list', baseOffset, baseOffset + raw.length);
        }
        return result;
    }
}

exports.AgentCommentParser = AgentCommentParser;
