/*
 * AGTree v3.0.0-alpha.1 (build date: Tue, 12 Nov 2024 16:11:58 GMT)
 * (c) 2024 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
'use strict';

var adblockers = require('../../utils/adblockers.js');
var constants = require('../../utils/constants.js');
var string = require('../../utils/string.js');
var index = require('../../nodes/index.js');
var logicalExpressionParser = require('../misc/logical-expression-parser.js');
var adblockSyntaxError = require('../../errors/adblock-syntax-error.js');
var parameterListParser = require('../misc/parameter-list-parser.js');
var options = require('../options.js');
var baseParser = require('../base-parser.js');
var valueParser = require('../misc/value-parser.js');

/**
 * Pre-processor directives
 *
 * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#pre-processor-directives}
 * @see {@link https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#pre-parsing-directives}
 */
/**
 * `PreProcessorParser` is responsible for parsing preprocessor rules.
 * Pre-processor comments are special comments that are used to control the behavior of the filter list processor.
 * Please note that this parser only handles general syntax for now, and does not validate the parameters at
 * the parsing stage.
 *
 * @example
 * If your rule is
 * ```adblock
 * !#if (adguard)
 * ```
 * then the directive's name is `if` and its value is `(adguard)`, but the parameter list
 * is not parsed / validated further.
 * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#pre-processor-directives}
 * @see {@link https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#pre-parsing-directives}
 */
class PreProcessorCommentParser extends baseParser.BaseParser {
    /**
     * Determines whether the rule is a pre-processor rule.
     *
     * @param raw Raw rule
     * @returns `true` if the rule is a pre-processor rule, `false` otherwise
     */
    static isPreProcessorRule(raw) {
        const trimmed = raw.trim();
        // Avoid this case: !##... (commonly used in AdGuard filters)
        return trimmed.startsWith(constants.PREPROCESSOR_MARKER) && trimmed[constants.PREPROCESSOR_MARKER_LEN] !== constants.HASHMARK;
    }
    /**
     * Parses a raw rule as a pre-processor comment.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns
     * Pre-processor comment AST or null (if the raw rule cannot be parsed as a pre-processor comment)
     */
    static parse(raw, options$1 = options.defaultParserOptions, baseOffset = 0) {
        // Ignore non-pre-processor rules
        if (!PreProcessorCommentParser.isPreProcessorRule(raw)) {
            return null;
        }
        let offset = 0;
        // Ignore whitespace characters before the rule (if any)
        offset = string.StringUtils.skipWS(raw, offset);
        // Ignore the pre-processor marker
        offset += constants.PREPROCESSOR_MARKER_LEN;
        // Ignore whitespace characters after the pre-processor marker (if any)
        // Note: this is incorrect according to the spec, but we do it for tolerance
        offset = string.StringUtils.skipWS(raw, offset);
        // Directive name should start at this offset, so we save this offset now
        const nameStart = offset;
        // Consume directive name, so parse the sequence until the first
        // whitespace / opening parenthesis / end of string
        while (offset < raw.length) {
            const ch = raw[offset];
            if (ch === constants.PREPROCESSOR_SEPARATOR || ch === constants.OPEN_PARENTHESIS) {
                break;
            }
            offset += 1;
        }
        // Save name end offset
        const nameEnd = offset;
        // Create name node
        const name = valueParser.ValueParser.parse(raw.slice(nameStart, nameEnd), options$1, baseOffset + nameStart);
        // Ignore whitespace characters after the directive name (if any)
        // Note: this may incorrect according to the spec, but we do it for tolerance
        offset = string.StringUtils.skipWS(raw, offset);
        // If the directive name is "safari_cb_affinity", then we have a special case
        if (name.value === constants.SAFARI_CB_AFFINITY) {
            // Throw error if there are spaces after the directive name
            if (offset > nameEnd) {
                throw new adblockSyntaxError.AdblockSyntaxError(`Unexpected whitespace after "${constants.SAFARI_CB_AFFINITY}" directive name`, baseOffset + nameEnd, baseOffset + offset);
            }
            // safari_cb_affinity directive optionally accepts a parameter list
            // So at this point we should check if there are parameters or not
            // (cb_affinity directive followed by an opening parenthesis or if we
            // skip the whitespace we reach the end of the string)
            if (string.StringUtils.skipWS(raw, offset) !== raw.length) {
                if (raw[offset] !== constants.OPEN_PARENTHESIS) {
                    throw new adblockSyntaxError.AdblockSyntaxError(`Unexpected character '${raw[offset]}' after '${constants.SAFARI_CB_AFFINITY}' directive name`, baseOffset + offset, baseOffset + offset + 1);
                }
                // If we have parameters, then we should parse them
                // Note: we don't validate the parameters at this stage
                // Ignore opening parenthesis
                offset += 1;
                // Save parameter list start offset
                const parameterListStart = offset;
                // Check for closing parenthesis
                const closingParenthesesIndex = string.StringUtils.skipWSBack(raw);
                if (closingParenthesesIndex === -1 || raw[closingParenthesesIndex] !== constants.CLOSE_PARENTHESIS) {
                    throw new adblockSyntaxError.AdblockSyntaxError(`Missing closing parenthesis for '${constants.SAFARI_CB_AFFINITY}' directive`, baseOffset + offset, baseOffset + raw.length);
                }
                // Save parameter list end offset
                const parameterListEnd = closingParenthesesIndex;
                // Parse parameters between the opening and closing parentheses
                const result = {
                    type: index.CommentRuleType.PreProcessorCommentRule,
                    category: index.RuleCategory.Comment,
                    syntax: adblockers.AdblockSyntax.Adg,
                    name,
                    // comma separated list of parameters
                    params: parameterListParser.ParameterListParser.parse(raw.slice(parameterListStart, parameterListEnd), options$1, baseOffset + parameterListStart, constants.COMMA),
                };
                if (options$1.includeRaws) {
                    result.raws = {
                        text: raw,
                    };
                }
                if (options$1.isLocIncluded) {
                    result.start = baseOffset;
                    result.end = baseOffset + raw.length;
                }
                return result;
            }
        }
        // If we reached the end of the string, then we have a directive without parameters
        // (e.g. "!#safari_cb_affinity" or "!#endif")
        // No need to continue parsing in this case.
        if (offset === raw.length) {
            // Throw error if the directive name is "if" or "include", because these directives
            // should have parameters
            if (name.value === constants.IF || name.value === constants.INCLUDE) {
                throw new adblockSyntaxError.AdblockSyntaxError(`Directive "${name.value}" requires parameters`, baseOffset, baseOffset + raw.length);
            }
            const result = {
                type: index.CommentRuleType.PreProcessorCommentRule,
                category: index.RuleCategory.Comment,
                syntax: adblockers.AdblockSyntax.Common,
                name,
            };
            if (options$1.includeRaws) {
                result.raws = {
                    text: raw,
                };
            }
            if (options$1.isLocIncluded) {
                result.start = baseOffset;
                result.end = baseOffset + raw.length;
            }
            return result;
        }
        // Get start and end offsets of the directive parameters
        const paramsStart = offset;
        const paramsEnd = string.StringUtils.skipWSBack(raw) + 1;
        // Prepare parameters node
        let params;
        // Parse parameters. Handle "if" and "safari_cb_affinity" directives
        // separately.
        if (name.value === constants.IF) {
            params = logicalExpressionParser.LogicalExpressionParser.parse(raw.slice(paramsStart, paramsEnd), options$1, baseOffset + paramsStart);
        }
        else {
            params = valueParser.ValueParser.parse(raw.slice(paramsStart, paramsEnd), options$1, baseOffset + paramsStart);
        }
        const result = {
            type: index.CommentRuleType.PreProcessorCommentRule,
            category: index.RuleCategory.Comment,
            syntax: adblockers.AdblockSyntax.Common,
            name,
            params,
        };
        if (options$1.includeRaws) {
            result.raws = {
                text: raw,
            };
        }
        if (options$1.isLocIncluded) {
            result.start = baseOffset;
            result.end = baseOffset + raw.length;
        }
        return result;
    }
}

exports.PreProcessorCommentParser = PreProcessorCommentParser;
