import { type AnyCosmeticRule } from '../../nodes';
import { BaseParser } from '../base-parser';
/**
 * Possible error messages for uBO selectors. Formatted with {@link sprintf}.
 */
export declare const ERROR_MESSAGES: {
    EMPTY_RULE_BODY: string;
    INVALID_BODY_FOR_SEPARATOR: string;
    MISSING_ADGUARD_MODIFIER_LIST_END: string;
    MISSING_ADGUARD_MODIFIER_LIST_MARKER: string;
    SYNTAXES_CANNOT_BE_MIXED: string;
    SYNTAX_DISABLED: string;
};
/**
 * `CosmeticRuleParser` is responsible for parsing cosmetic rules.
 *
 * Where possible, it automatically detects the difference between supported syntaxes:
 *  - AdGuard
 *  - uBlock Origin
 *  - Adblock Plus
 *
 * If the syntax is common / cannot be determined, the parser gives `Common` syntax.
 *
 * Please note that syntactically correct rules are parsed even if they are not actually
 * compatible with the given adblocker. This is a completely natural behavior, meaningful
 * checking of compatibility is not done at the parser level.
 */
export declare class CosmeticRuleParser extends BaseParser {
    /**
     * Determines whether a rule is a cosmetic rule. The rule is considered cosmetic if it
     * contains a cosmetic rule separator.
     *
     * @param raw Raw rule
     * @returns `true` if the rule is a cosmetic rule, `false` otherwise
     */
    static isCosmeticRule(raw: string): boolean;
    /**
     * Parses a cosmetic rule. The structure of the cosmetic rules:
     *  - pattern (AdGuard pattern can have modifiers, other syntaxes don't)
     *  - separator
     *  - body
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns
     * Parsed cosmetic rule AST or null if it failed to parse based on the known cosmetic rules
     * @throws If the input matches the cosmetic rule pattern but syntactically invalid
     */
    static parse(raw: string, options?: import("../options").ParserOptions, baseOffset?: number): AnyCosmeticRule | null;
}
