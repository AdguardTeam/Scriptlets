/*
 * AGTree v3.0.0-alpha.1 (build date: Tue, 12 Nov 2024 16:11:58 GMT)
 * (c) 2024 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
'use strict';

var string = require('../../utils/string.js');
var constants = require('../../utils/constants.js');
var options = require('../options.js');
var valueParser = require('./value-parser.js');
var adblockSyntaxError = require('../../errors/adblock-syntax-error.js');
var quotes = require('../../utils/quotes.js');
var parameterListParser = require('./parameter-list-parser.js');

class UboParameterListParser extends parameterListParser.ParameterListParser {
    /**
     * Parses an "uBO-specific parameter list".
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @param separator Separator character (default: comma).
     * @param requireQuotes Whether to require quotes around the parameter values (default: false).
     * @param supportedQuotes Set of accepted quotes (default: {@link QUOTE_SET}).
     * @returns Parameter list node.
     *
     * @note Based on {@link https://github.com/gorhill/uBlock/blob/f9ab4b75041815e6e5690d80851189ae3dc660d0/src/js/static-filtering-parser.js#L607-L699} to provide consistency.
     */
    static parse(raw, options$1 = options.defaultParserOptions, baseOffset = 0, separator = constants.COMMA, requireQuotes = false, supportedQuotes = quotes.QUOTE_SET) {
        // Prepare the parameter list node
        const params = {
            type: 'ParameterList',
            children: [],
        };
        const { length } = raw;
        if (options$1.isLocIncluded) {
            params.start = baseOffset;
            params.end = baseOffset + length;
        }
        let offset = 0;
        // TODO: Eliminate the need for extraNull
        let extraNull = false;
        while (offset < length) {
            offset = string.StringUtils.skipWS(raw, offset);
            const paramStart = offset;
            let paramEnd = offset;
            if (supportedQuotes.has(raw[offset])) {
                // Find the closing quote
                const possibleClosingQuoteIndex = string.StringUtils.findNextUnescapedCharacter(raw, raw[offset], offset + 1);
                if (possibleClosingQuoteIndex !== -1) {
                    // Next non-whitespace character after the closing quote should be the separator
                    const nextSeparatorIndex = string.StringUtils.skipWS(raw, possibleClosingQuoteIndex + 1);
                    if (nextSeparatorIndex === length) {
                        // If the separator is not found, the param end is the end of the string
                        paramEnd = string.StringUtils.skipWSBack(raw, length - 1) + 1;
                        offset = length;
                    }
                    else if (raw[nextSeparatorIndex] === separator) {
                        // If the quote is followed by a separator, we can use it as a closing quote
                        paramEnd = possibleClosingQuoteIndex + 1;
                        offset = nextSeparatorIndex + 1;
                    }
                    else {
                        if (requireQuotes) {
                            throw new adblockSyntaxError.AdblockSyntaxError(`Expected separator, got: '${raw[nextSeparatorIndex]}'`, baseOffset + nextSeparatorIndex, baseOffset + length);
                        }
                        /**
                         * At that point found `possibleClosingQuoteIndex` is wrong
                         * | is `offset`
                         * ~ is `possibleClosingQuoteIndex`
                         * ^ is `nextSeparatorIndex`
                         *
                         * Example 1: "abc, ').cba='1'"
                         *                  |      ~^
                         * Example 2: "abc, ').cba, '1'"
                         *                  |       ~^
                         * Example 3: "abc, ').cba='1', cba"
                         *                  |      ~^
                         *
                         * Search for separator before `possibleClosingQuoteIndex`
                         */
                        const separatorIndexBeforeQuote = string.StringUtils.findNextUnescapedCharacterBackwards(raw, separator, possibleClosingQuoteIndex, constants.ESCAPE_CHARACTER, offset + 1);
                        if (separatorIndexBeforeQuote !== -1) {
                            // Found separator before (Example 2)
                            paramEnd = string.StringUtils.skipWSBack(raw, separatorIndexBeforeQuote - 1) + 1;
                            offset = separatorIndexBeforeQuote + 1;
                        }
                        else {
                            // Didn't found separator before, search after
                            const separatorIndexAfterQuote = string.StringUtils.findNextUnescapedCharacter(raw, separator, possibleClosingQuoteIndex);
                            if (separatorIndexAfterQuote !== -1) {
                                // We found separator after (Example 3)
                                paramEnd = string.StringUtils.skipWSBack(raw, separatorIndexAfterQuote - 1) + 1;
                                offset = separatorIndexAfterQuote + 1;
                            }
                            else {
                                // If the separator is not found, the param end is the end of the string (Example 1)
                                paramEnd = string.StringUtils.skipWSBack(raw, length - 1) + 1;
                                offset = length;
                            }
                        }
                    }
                }
                else {
                    if (requireQuotes) {
                        throw new adblockSyntaxError.AdblockSyntaxError('Expected closing quote, got end of string', baseOffset + offset, baseOffset + length);
                    }
                    // If the closing quote is not found, the param end is the end of the string
                    paramEnd = string.StringUtils.skipWSBack(raw, length - 1) + 1;
                    offset = length;
                }
            }
            else {
                if (requireQuotes) {
                    throw new adblockSyntaxError.AdblockSyntaxError(`Expected quote, got: '${raw[offset]}'`, baseOffset + offset, baseOffset + length);
                }
                const nextSeparator = string.StringUtils.findNextUnescapedCharacter(raw, separator, offset);
                if (nextSeparator === -1) {
                    // If the separator is not found, the param end is the end of the string
                    paramEnd = string.StringUtils.skipWSBack(raw, length - 1) + 1;
                    offset = length;
                }
                else {
                    // Param end should be the last non-whitespace character before the separator
                    paramEnd = string.StringUtils.skipWSBack(raw, nextSeparator - 1) + 1;
                    offset = nextSeparator + 1;
                    if (string.StringUtils.skipWS(raw, length - 1) === nextSeparator) {
                        extraNull = true;
                    }
                }
            }
            if (paramStart < paramEnd) {
                params.children.push(valueParser.ValueParser.parse(raw.slice(paramStart, paramEnd), options$1, baseOffset + paramStart));
            }
            else {
                params.children.push(null);
            }
        }
        if (extraNull) {
            params.children.push(null);
        }
        return params;
    }
}

exports.UboParameterListParser = UboParameterListParser;
