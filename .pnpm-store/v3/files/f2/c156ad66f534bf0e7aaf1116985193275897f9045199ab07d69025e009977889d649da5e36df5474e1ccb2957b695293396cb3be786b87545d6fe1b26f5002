{"version":3,"file":"index.mjs","sources":["../src/make-error.ts","../src/safe-regex.ts","../src/trim-lines.ts","../src/skip-es6-str.ts","../src/skip-quotes.ts","../src/handle-comment.ts","../src/skip-re-or-cm.ts","../src/cleanup-buffer.ts","../src/predef-filters.ts","../src/get-filter-fn.ts","../src/create-context.ts","../src/index.ts"],"sourcesContent":["/**\n * Augments the error with the position of the error into the source.\n *\n * @param err Error object\n * @param pos Absolute position into the buffer (base 0)\n */\nconst makeError = function (err: Error, pos: number) {\n  ;(err as any).position = pos\n  return err\n}\n\nexport default makeError\n","import { EOL } from 'perf-regexes'\n\n/**\n * Replaces the marker '@LE' with line-endings characters in the regex.\n * Safe to use with minifiers.\n *\n * @param re Regex to replace\n * @param flags Regex flags\n */\nconst safeRegex = (re: RegExp, flags?: string) =>\n  new RegExp(re.source.replace(/@LE/g, EOL.source), flags)\n\nexport default safeRegex\n","import safeRegex from './safe-regex'\n\n/**\n * Source to match consecutive whitespace that ends in a line-ending of any\n * type. The whitespace can include other line-endings.\n */\n// eslint-disable-next-line unicorn/better-regex\nconst sAllLines = safeRegex(/\\s*(?:@LE)/).source\n\n/**\n * Matches one line-endings and its leading characters.\n */\n// eslint-disable-next-line unicorn/better-regex\nconst reEachLine = safeRegex(/.*(?:@LE)/, 'g')\n\n/**\n * Normalizes and compacts a block of blank characters to convert it into a\n * block of line-endings that do not exceed the maximum number defined by the\n * user.\n *\n * @param ctx Maximum number of *characters* for the empty lines\n * @param str Block of blank characters to search on\n * @param first This is the first block\n */\nconst packLines = (ctx: Context, str: string, first: boolean) => {\n  //\n  // First case, no empty lines\n  if (!ctx.empties) {\n    return first ? '' : ctx.eolChar\n  }\n\n  // Normalize eols and discard other characters in this region\n  str = str.replace(reEachLine, ctx.eolChar)\n\n  // Second case, limit to max N lines\n  if (ctx.empties > 0) {\n    const limit = first ? ctx.maxTopLen : ctx.maxEols.length\n\n    if (str.length > limit) {\n      return str.substr(0, limit)\n    }\n  }\n\n  // Third case is keep all the empty lines, so do nothing more\n  return str\n}\n\n/**\n * Normalizes and compacts the region of consecutive whitespace.\n *\n * @param ctx Execution context\n * @param mm Regex result with the index and content to squash\n * @param end Ending of the region\n */\nconst squashRegion = (ctx: Context, mm: RegExpExecArray, end: number) => {\n  // Get the start position and content of the region to squash.\n  const start = mm.index\n  const oldStr = mm[0]\n\n  // Optimize the high frecuency case of one only normalized eol,\n  // but not at start\n  if (start > 0 && oldStr === ctx.eolChar) {\n    return\n  }\n\n  // Compact intermediate lines, if `maxEmptyLines` is zero all blank lines\n  // are removed. If it is -1 the spaces are removed, keeping the EOLs.\n  const newStr = packLines(ctx, oldStr, !start)\n\n  if (oldStr !== newStr) {\n    ctx.magicStr.overwrite(start, end, newStr)\n    ctx.changes = true\n  }\n}\n\n/**\n * Normalizes and compacts lines in a block of text.\n *\n * @param ctx Execution context\n * @--param start Offset of the start of the region\n * @param end Ending of the region\n */\nconst trimLines = function (ctx: Context, end: number) {\n  if (ctx.start >= end) {\n    return\n  }\n\n  const buffer = ctx.buff\n  const re = new RegExp(sAllLines, 'g')\n\n  re.lastIndex = ctx.start\n  let mm = re.exec(buffer)\n\n  while (mm) {\n    if (mm.index >= end) {\n      ctx.start = end\n      return\n    }\n\n    ctx.start = re.lastIndex\n\n    squashRegion(ctx, mm, ctx.start)\n\n    mm = re.exec(buffer)\n  }\n}\n\nexport default trimLines\n","import makeError from './make-error'\nimport trimLines from './trim-lines'\n\n/** Flag for ES6 TL in the stack */\nconst ES6_BQ = '`'\n\n/**\n * Searches the next backtick that signals the end of the ES6 Template Literal\n * or the sequence \"${\" that starts a sub-expression, skipping any escaped\n * character.\n *\n * @param buffer Whole code\n * @param start Starting position of the template\n * @param stack To save nested ES6 TL positions\n * @returns The end of the string (-1 if not found).\n */\nconst skipTL = (buffer: string, start: number, stack: string[]) => {\n  //\n  // Only three characters are of interest to this function\n  const re = /[$\\\\`]/g\n\n  // `start` points to the a backtick inside `code`\n  re.lastIndex = start + 1\n\n  while (re.exec(buffer)) {\n    const pos = re.lastIndex\n    const c = buffer[pos - 1]\n\n    if (c === ES6_BQ) {\n      return pos // found the end of this TL\n    }\n\n    if (c === '\\\\') {\n      re.lastIndex = pos + 1 // Skip this escaped char\n      //\n    } else if (buffer[pos] === '{') {\n      /*\n        In a sub-expression, push a backtick in the stack.\n        When the calling loop finds a closing brace and see the backtick,\n        it will restore the ES6 TL parsing mode.\n      */\n      stack.push(ES6_BQ)\n      return pos + 1\n    }\n  }\n\n  throw makeError(new Error('Unclosed ES6 Template Literal.'), start)\n}\n\n/**\n * Handles ES6 TL.\n *\n * Line trimming is done here and the position is shifted so that trimLines\n * does not touch the literals.\n *\n * @param ctx Execution context\n * @param start Start of the ES6 TL\n */\nconst skipES6Str = function (ctx: Context, start: number) {\n  //\n  trimLines(ctx, start)\n\n  ctx.start = skipTL(ctx.buff, start, ctx.stack)\n\n  return ctx.start\n}\n\nexport default skipES6Str\n","import { JS_DQSTR, JS_SQSTR } from 'perf-regexes'\nimport makeError from './make-error'\n\n/**\n * Searches the end of a single or double-quoted string.\n *\n * @param ctx Execution context\n * @param index Start of the string\n */\nconst skipQuotes = function (ctx: Context, index: number) {\n  const buffer = ctx.buff\n  const re = buffer[index] === '\"' ? JS_DQSTR : JS_SQSTR\n\n  re.lastIndex = index\n\n  if (!re.exec(buffer)) {\n    throw makeError(new Error(`Unclosed string.`), index)\n  }\n\n  return re.lastIndex\n}\n\nexport default skipQuotes\n","import { EOL, JS_MLCMNT, JS_SLCMNT } from 'perf-regexes'\nimport makeError from './make-error'\nimport trimLines from './trim-lines'\n\n/**\n * Matches non-line-endings characters\n */\nconst R_NOEOLS = /[^\\n\\r\\u2028\\u2029]+/g\n\n/**\n * By using premaked string of spaces, blankBlock is faster than\n * block.replace(/[^ \\n]+/, ' ').\n */\nconst spaces = new Array(150).join(' ')\n\n/**\n * Helper function to convert characters in spaces, except EOLs.\n * @param str Block to convert\n */\nconst blankBlock = (str: string) => {\n  const len = str.length\n  str = spaces\n\n  while (str.length < len) {\n    str += spaces\n  }\n\n  return str.slice(0, len)\n}\n\n/**\n * Returns `true` if a comment must be removed due there's non-blank\n * content after it in the same line.\n */\nconst removeThis = (ctx: Context, end: number) => {\n  const buffer = ctx.buff\n  let ch\n\n  // Find the next non-space to the right, or the end of the buffer.\n  while (end < buffer.length) {\n    ch = buffer[end]\n\n    // Found an EOL, let the caller handle this\n    if (ch === '\\n' || ch === '\\r') {\n      return false\n    }\n\n    // Found non-space, we need remove this comment\n    if (/\\S/.test(ch)) {\n      return true\n    }\n\n    end++\n  }\n\n  return false\n}\n\n/**\n * Handle comments that must be removed.\n *\n * If the comment is multi-line and does not ends with an EOL, remove it\n * here because the caller will not do that.\n *\n * Other comments are only replaced with blanks, except its line-endings,\n * and either `trimLines` or `finalTrim` will remove it in a later step.\n */\nconst rmComment = (ctx: Context, start: number, end: number) => {\n  const buffer = ctx.buff\n\n  // Multiline comments, if they are not isolated, should be removed here,\n  // since trimLines will not see it.\n  if (buffer[start + 1] === '*' && removeThis(ctx, end)) {\n    ctx.magicStr.overwrite(start, end, '')\n    ctx.changes = true\n  }\n\n  // Replace the comment with spaces, except EOLs, so in a future step\n  // trimLines can normalize and compact it in a right way.\n  ctx.buff =\n    buffer.substr(0, start) +\n    buffer.slice(start, end).replace(R_NOEOLS, blankBlock) +\n    buffer.substr(end)\n}\n\n/**\n * Called when the option `compactComments` is `false`, preserves the\n * whitespace within the comment, only normalizing line-ending.\n *\n * @param ctx Execution context\n * @param start Start of the comment\n * @param end Ending position of the comment\n */\nconst normalize = (ctx: Context, start: number, end: number) => {\n  //\n  // Trim the previous block up to the beginning of this comment\n  trimLines(ctx, start)\n\n  // Only normalize the line-endings within the comment\n  const str = ctx.buff.slice(start, end).replace(EOL, ctx.eolChar)\n  ctx.magicStr.overwrite(start, end, str)\n  ctx.changes = true\n\n  // ...and adjust `start` to prevent trimLines from touching it.\n  ctx.start = end\n}\n\n/** Matches comments */\nconst reCmnt = {\n  '*': JS_MLCMNT,\n  '/': JS_SLCMNT,\n}\n\n/**\n * Comment handler.\n *\n * If compactComments is `false`, line compaction must be done here\n * and update the start position in the execution context.\n *\n * @param ctx Execution context\n * @param start Start of this comment\n * @param ch Type of this comment, either '*' or '/'\n */\nconst handleComment = function (ctx: Context, start: number, ch: '*' | '/') {\n  //\n  const re = reCmnt[ch]\n  re.lastIndex = start\n\n  const mm = re.exec(ctx.buff)\n\n  if (mm == null || mm.index !== start) {\n    throw makeError(new Error(`Unclosed comment.`), start)\n  }\n\n  const end = re.lastIndex\n\n  if (ctx.filter(mm)) {\n    // This comment must be removed or replaced by spaces.\n    rmComment(ctx, start, end)\n    //\n  } else if (!ctx.compact && ch === '*') {\n    // Preserve whitespace of this comment, only normalize lines.\n    normalize(ctx, start, end)\n  }\n\n  return end // trimLines will preserve and compact this comment\n}\n\nexport default handleComment\n","import skipRegex from 'skip-regex'\nimport handleComment from './handle-comment'\n\n/**\n * Handles slashes, which can initiate a regex or comment.\n *\n * @param ctx Execution context\n * @param index Position of the slash\n */\nconst skipReOrCm = function (ctx: Context, index: number) {\n  /*\n    This function is always called with an out-of-string slash, so\n    if it is followed by '*' or '/' it _must be_ a comment.\n\n    If it isn't followed by any of those characters, it could be\n    a regex or a division sign, any of which skipRegex will jump.\n  */\n  const ch = ctx.buff[index + 1]\n\n  if (ch === '*' || ch === '/') {\n    return handleComment(ctx, index, ch)\n  }\n\n  // will returns index+1 if it is not a regex\n  return skipRegex(ctx.buff, index)\n}\n\nexport default skipReOrCm\n","import makeError from './make-error'\nimport skipES6Str from './skip-es6-str'\nimport skipQuotes from './skip-quotes'\nimport skipReOrCm from './skip-re-or-cm'\nimport trimLines from './trim-lines'\n\ntype SkipFn = (ctx: Context, idx: number) => number\n\n/** Matches the last whitespace of the buffer */\nconst reFinalSpc = /\\s+$/g\n\n/**\n * Trims trailing spaces of the whole buffer.\n *\n * @param ctx Execution context\n * @param start Start of trainling part, can contain non-blank chars\n */\nconst finish = (ctx: Context) => {\n  //\n  // Get trailing whitespace beginning at the last start position\n  reFinalSpc.lastIndex = ctx.start\n  const mm = reFinalSpc.exec(ctx.buff)\n\n  if (mm) {\n    // Searches trailing spaces\n    const pos = mm[0].search(/.+$/)\n\n    // istanbul ignore else: `pos` should always be >=0\n    if (~pos) {\n      ctx.magicStr.overwrite(mm.index! + pos, ctx.buff.length, '')\n      ctx.changes = true\n    }\n  }\n\n  return ctx.changes\n}\n\nconst uncloseMessage = (ctx: Context) =>\n  `Unclosed ${ctx.stack.pop() === '}' ? 'bracket' : 'ES6 Template'}.`\n\n/**\n * Handles closing brackets. It can be a regular bracket or one closing an\n * ES6 TL expression.\n *\n * @param ctx Execution context\n * @param start Position of this bracket\n */\nconst skipBracket = (ctx: Context, start: number) => {\n  const ch = ctx.stack.pop()\n\n  if (ch == null) {\n    throw makeError(new Error('Unexpected character \"}\"'), start)\n  }\n\n  if (ch === '`') {\n    return skipES6Str(ctx, start)\n  }\n\n  return start + 1 // skip this\n}\n\n/**\n * Pushes a regular JS bracket into the stack.\n *\n * @param ctx Execution context\n * @param index Bracket position\n */\nconst pushBracket = (ctx: Context, index: number) => {\n  ctx.stack.push('}')\n  return index + 1\n}\n\n/**\n * Functions to process the next significant character in the buffer.\n */\nconst skipFn: { [k: string]: SkipFn } = {\n  '\"': skipQuotes,\n  \"'\": skipQuotes,\n  '`': skipES6Str,\n  '{': pushBracket,\n  '}': skipBracket,\n  '/': skipReOrCm,\n}\n\n/**\n * Main function for removal of empty lines and comments.\n *\n * @param ctx Execution context\n * @param parser Acorn parser and options\n * @returns `true` if the buffer changed.\n */\nconst cleanupBuffer = function (ctx: Context) {\n  const re = /[\"'/`{}]/g\n\n  // Don't cache buff\n  let fn: SkipFn\n  let mm = re.exec(ctx.buff)\n\n  while (mm) {\n    fn = skipFn[mm[0]]\n    re.lastIndex = fn(ctx, mm.index)\n    mm = re.exec(ctx.buff)\n  }\n\n  if (ctx.stack.length) {\n    throw new Error(uncloseMessage(ctx))\n  }\n\n  trimLines(ctx, ctx.buff.length)\n\n  return finish(ctx)\n}\n\nexport default cleanupBuffer\n","/**\n * Predefined filters.\n *\n * None of this is really accurate, js-cleanup is not a parser, but they\n * are suitable for the job without introducing more complexity.\n */\nconst predefFilters: { [k: string]: RegExp } = {\n  /* eslint-disable unicorn/better-regex */\n\n  // The default filter\n  some: /^.!|@(?:license|preserve)\\b/,\n\n  // Only license\n  license: /@license\\b/,\n\n  // http://eslint.org/docs/user-guide/configuring\n  eslint: /^\\*\\s*(?:eslint(?:\\s|-env\\s|-(?:en|dis)able(?:\\s|$))|global\\s)|^.[\\t ]*eslint-disable-(?:next-)?line(?:[\\t ]|$)/,\n\n  // https://flow.org/en/docs\n  flow: /^.\\s*(?:@flow(?:\\s|$)|\\$Flow[A-Za-z]|flowlint\\s|flowlint(?:-next)?-line[\\t ])|^\\*[\\t ]*(?:flow-include\\s|:{1,3}[^:])/,\n\n  // https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md\n  istanbul: /^.\\s*istanbul\\s+ignore\\s+[a-z]/,\n\n  // http://usejsdoc.org\n  jsdoc: /^\\*\\*[\\S\\s]*@[a-z]{2}/,\n\n  // http://jshint.com/docs/#inline-configuration\n  jshint: /^.\\s*(?:jshint|globals|exported)\\s/,\n\n  // http://www.jslint.com/help.html\n  jslint: /^.(?:jslint|global|property)\\s\\S/,\n\n  // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps\n  sources: /^.[#@][\\t ]+source(?:Mapping)?URL=/,\n\n  // http://www.typescriptlang.org/docs\n  ts: /^(?:\\/\\/\\s*<(?:reference\\s|amd-[a-z]).*>|.\\s*@(?:jsx[\\t ]|ts-(?:check|nocheck|ignore)\\b))/,\n\n  // http://www.typescriptlang.org/docs/handbook/triple-slash-directives.html\n  ts3s: /^\\/\\/\\s*<(?:reference\\s|amd-[a-z]).*>/,\n}\n\nexport default predefFilters\n","import predefFilters from './predef-filters'\n\nconst hasOwnProp = Object.prototype.hasOwnProperty\n\n/**\n * Parses an individual filter.\n *\n * @param filter Filter\n */\nconst parseEach = (filter: string | RegExp) => {\n  //\n  if (filter instanceof RegExp) {\n    return filter\n  }\n\n  if (hasOwnProp.call(predefFilters, filter)) {\n    return predefFilters[filter]\n  }\n\n  throw new Error(`cleanup: unknown comment filter: \"${filter}\"`)\n}\n\n/**\n * Makes the regexes to filter out comments.\n *\n * @param list User filters\n */\nconst makeFilters = (list?: string | RegExp | (string | RegExp)[]) => {\n  //\n  if (list == null) {\n    return [predefFilters.some]\n  }\n\n  const filters = Array.isArray(list) ? list : [list]\n\n  if (~filters.indexOf('all')) {\n    return true\n  }\n\n  if (~filters.indexOf('none')) {\n    return false\n  }\n\n  return filters.map(parseEach)\n}\n\n/**\n * Return a function that determinates if a comment must be removed.\n *\n * @param list Default or defined comment filters\n */\nconst getFilterFn = function (list?: string | RegExp | (string | RegExp)[]) {\n  const filters = makeFilters(list)\n\n  if (filters === true) {\n    return () => false\n  }\n\n  if (filters === false) {\n    return () => true\n  }\n\n  /**\n   * Determinates if a comment must be preserved.\n   *\n   * @param ctx Execution context\n   * @param start Start of the whole comment\n   * @param end End of the whole comment\n   */\n  const mustRemove = function (mm: RegExpExecArray) {\n    let content = mm[0]\n\n    // Extract the content, including the `isBlock` indicator\n    content = content[1] === '*' ? content.slice(1, -2) : content.slice(1)\n\n    // Search a filter that matches the content\n    return !filters.some(filter => filter.test(content))\n  }\n\n  return mustRemove\n}\n\nexport default getFilterFn\n","import MagicString from 'magic-string'\nimport getFilterFn from './get-filter-fn'\n\nimport type { Options } from '..'\n\nconst getEol = (type?: string) => (type === 'win' ? '\\r\\n' : type === 'mac' ? '\\r' : '\\n')\n\n/**\n * Creates the execution context.\n *\n * @param buffer Source text\n * @param options User options\n */\nconst createContext = function (buffer: string, options: Options): Context {\n  //\n  const eolChar = getEol(options.lineEndings)\n  const empties = (options.maxEmptyLines as any) | 0\n  const maxEols = empties < 0 ? '' : new Array(empties + 2).join(eolChar)\n\n  return {\n    changes: false,\n    buff: buffer,\n    compact: options.compactComments !== false,\n    empties,\n    eolChar,\n    start: 0,\n    stack: [],\n    maxTopLen: empties >= 0 ? empties * eolChar.length : -1,\n    maxEols,\n    magicStr: new MagicString(buffer),\n    filter: getFilterFn(options.comments),\n  }\n}\n\nexport default createContext\n","import cleanupBuffer from './cleanup-buffer'\nimport createContext from './create-context'\n\nimport type { Options, Result } from '..'\n\n/**\n * Get the options for the sourcemap.\n */\nconst getMapOpts = (options: Options, file: string) => {\n  const opts = options.sourcemapOptions || {}\n\n  return {\n    source: file,\n    includeContent: opts.includeContent === true,\n    inlineMap: opts.inlineMap === true,\n    hires: opts.hires !== false,\n  }\n}\n\n/**\n * Creates the result.\n *\n * @param ctx Execution context\n * @param file Source filename\n * @param options User options\n */\nconst genChangedRes = (ctx: Context, file: string, options: Options) => {\n  const mapOpts = options.sourcemap !== false && getMapOpts(options, file)\n  const result: Result = {\n    code: ctx.magicStr.toString(),\n  }\n\n  if (mapOpts) {\n    const map = ctx.magicStr.generateMap(mapOpts)\n\n    if (mapOpts.inlineMap) {\n      result.code += `\\n//# sourceMappingURL=${map.toUrl()};`\n    } else {\n      result.map = map\n    }\n  }\n\n  return result\n}\n\n/**\n * Smart comment and whitespace cleaner for JavaScript-like files.\n *\n * @param code Source buffer\n * @param file Source filename\n * @param options User options\n */\nconst cleanup = function (code: string, file?: string | null, options?: Options): Result {\n  options = options || {}\n\n  const context = createContext(code, options)\n  const changes = cleanupBuffer(context)\n\n  return changes\n    ? genChangedRes(context, file || '', options)\n    : options.sourcemap !== false\n      ? { code, map: null }\n      : { code }\n}\n\nexport default cleanup\n"],"names":[],"mappings":"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"}