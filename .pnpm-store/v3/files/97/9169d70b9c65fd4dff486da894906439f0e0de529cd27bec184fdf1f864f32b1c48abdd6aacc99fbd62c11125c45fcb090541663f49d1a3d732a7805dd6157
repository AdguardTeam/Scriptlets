/*
 * AGTree v3.0.0-alpha.1 (build date: Tue, 12 Nov 2024 16:11:58 GMT)
 * (c) 2024 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
'use strict';

var constants = require('./constants.js');

/**
 * @file Regular expression utilities
 */
// Special RegExp constants
const REGEX_START = constants.CARET; // '^'
const REGEX_END = constants.DOLLAR_SIGN; // '$'
const REGEX_ANY_CHARACTERS = constants.DOT + constants.ASTERISK; // '.*'
// Special adblock pattern symbols and their RegExp equivalents
const ADBLOCK_URL_START = constants.PIPE + constants.PIPE; // '||'
const ADBLOCK_URL_START_REGEX = '^(http|https|ws|wss)://([a-z0-9-_.]+\\.)?';
const ADBLOCK_URL_SEPARATOR = constants.CARET; // '^'
const ADBLOCK_URL_SEPARATOR_REGEX = '([^ a-zA-Z0-9.%_-]|$)';
const ADBLOCK_WILDCARD = constants.ASTERISK; // '*'
const ADBLOCK_WILDCARD_REGEX = REGEX_ANY_CHARACTERS;
// Negation wrapper for RegExp patterns
const REGEX_NEGATION_PREFIX = '^((?!';
const REGEX_NEGATION_SUFFIX = ').)*$';
/**
 * Special RegExp symbols
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#special-escape
 */
const SPECIAL_REGEX_SYMBOLS = new Set([
    constants.ASTERISK,
    constants.CARET,
    constants.CLOSE_CURLY_BRACKET,
    constants.CLOSE_PARENTHESIS,
    constants.CLOSE_SQUARE_BRACKET,
    constants.DOLLAR_SIGN,
    constants.DOT,
    constants.ESCAPE_CHARACTER,
    constants.OPEN_CURLY_BRACKET,
    constants.OPEN_PARENTHESIS,
    constants.OPEN_SQUARE_BRACKET,
    constants.PIPE,
    constants.PLUS,
    constants.QUESTION_MARK,
    constants.SLASH,
]);
/**
 * Utility functions for working with RegExp patterns
 */
class RegExpUtils {
    /**
     * Checks whether a string possibly is a RegExp pattern.
     * Flags are not supported.
     *
     * Note: it does not perform a full validation of the pattern,
     * it just checks if the string starts and ends with a slash.
     *
     * @param pattern - Pattern to check
     * @returns `true` if the string is a RegExp pattern, `false` otherwise
     */
    static isRegexPattern(pattern) {
        const trimmedPattern = pattern.trim();
        // Avoid false positives
        return trimmedPattern.length > constants.REGEX_MARKER.length * 2
            && trimmedPattern.startsWith(constants.REGEX_MARKER)
            && trimmedPattern.endsWith(constants.REGEX_MARKER)
            && trimmedPattern[constants.REGEX_MARKER.length - 2] !== constants.ESCAPE_CHARACTER;
    }
    /**
     * Negates a RegExp pattern. Technically, this method wraps the pattern in `^((?!` and `).)*$`.
     *
     * RegExp modifiers are not supported.
     *
     * @param pattern Pattern to negate (can be wrapped in slashes or not)
     * @returns Negated RegExp pattern
     */
    static negateRegexPattern(pattern) {
        let result = pattern.trim();
        let slashes = false;
        // Remove the leading and trailing slashes (/)
        if (RegExpUtils.isRegexPattern(result)) {
            result = result.substring(constants.REGEX_MARKER.length, result.length - constants.REGEX_MARKER.length);
            slashes = true;
        }
        // Only negate the pattern if it's not already negated
        if (!(result.startsWith(REGEX_NEGATION_PREFIX) && result.endsWith(REGEX_NEGATION_SUFFIX))) {
            // Remove leading caret (^)
            if (result.startsWith(REGEX_START)) {
                result = result.substring(REGEX_START.length);
            }
            // Remove trailing dollar sign ($)
            if (result.endsWith(REGEX_END)) {
                result = result.substring(0, result.length - REGEX_END.length);
            }
            // Wrap the pattern in the negation
            result = `${REGEX_NEGATION_PREFIX}${result}${REGEX_NEGATION_SUFFIX}`;
        }
        // Add the leading and trailing slashes back if they were there
        if (slashes) {
            result = `${constants.REGEX_MARKER}${result}${constants.REGEX_MARKER}`;
        }
        return result;
    }
    /**
     * Converts a basic adblock rule pattern to a RegExp pattern. Based on
     * https://github.com/AdguardTeam/tsurlfilter/blob/9b26e0b4a0e30b87690bc60f7cf377d112c3085c/packages/tsurlfilter/src/rules/simple-regex.ts#L219
     *
     * @param pattern Pattern to convert
     * @returns RegExp equivalent of the pattern
     * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#basic-rules}
     */
    static patternToRegexp(pattern) {
        const trimmed = pattern.trim();
        // Return regex for any character sequence if the pattern is just |, ||, * or empty
        if (trimmed === ADBLOCK_URL_START
            || trimmed === constants.PIPE
            || trimmed === ADBLOCK_WILDCARD
            || trimmed === constants.EMPTY) {
            return REGEX_ANY_CHARACTERS;
        }
        // If the pattern is already a RegExp, just return it, but remove the leading and trailing slashes
        if (RegExpUtils.isRegexPattern(pattern)) {
            return pattern.substring(constants.REGEX_MARKER.length, pattern.length - constants.REGEX_MARKER.length);
        }
        let result = constants.EMPTY;
        let offset = 0;
        let len = trimmed.length;
        // Handle leading pipes
        if (trimmed[0] === constants.PIPE) {
            if (trimmed[1] === constants.PIPE) {
                // Replace adblock url start (||) with its RegExp equivalent
                result += ADBLOCK_URL_START_REGEX;
                offset = ADBLOCK_URL_START.length;
            }
            else {
                // Replace single pipe (|) with the RegExp start symbol (^)
                result += REGEX_START;
                offset = REGEX_START.length;
            }
        }
        // Handle trailing pipes
        let trailingPipe = false;
        if (trimmed.endsWith(constants.PIPE)) {
            trailingPipe = true;
            len -= constants.PIPE.length;
        }
        // Handle the rest of the pattern, if any
        for (; offset < len; offset += 1) {
            if (trimmed[offset] === ADBLOCK_WILDCARD) {
                // Replace adblock wildcard (*) with its RegExp equivalent
                result += ADBLOCK_WILDCARD_REGEX;
            }
            else if (trimmed[offset] === ADBLOCK_URL_SEPARATOR) {
                // Replace adblock url separator (^) with its RegExp equivalent
                result += ADBLOCK_URL_SEPARATOR_REGEX;
            }
            else if (SPECIAL_REGEX_SYMBOLS.has(trimmed[offset])) {
                // Escape special RegExp symbols (we handled pipe (|) and asterisk (*) already)
                result += constants.ESCAPE_CHARACTER + trimmed[offset];
            }
            else {
                // Just add any other character
                result += trimmed[offset];
            }
        }
        // Handle trailing pipes
        if (trailingPipe) {
            // Replace trailing pipe (|) with the RegExp end symbol ($)
            result += REGEX_END;
        }
        return result;
    }
}

exports.ADBLOCK_URL_SEPARATOR = ADBLOCK_URL_SEPARATOR;
exports.ADBLOCK_URL_SEPARATOR_REGEX = ADBLOCK_URL_SEPARATOR_REGEX;
exports.ADBLOCK_URL_START = ADBLOCK_URL_START;
exports.ADBLOCK_URL_START_REGEX = ADBLOCK_URL_START_REGEX;
exports.ADBLOCK_WILDCARD = ADBLOCK_WILDCARD;
exports.ADBLOCK_WILDCARD_REGEX = ADBLOCK_WILDCARD_REGEX;
exports.REGEX_ANY_CHARACTERS = REGEX_ANY_CHARACTERS;
exports.REGEX_END = REGEX_END;
exports.REGEX_NEGATION_PREFIX = REGEX_NEGATION_PREFIX;
exports.REGEX_NEGATION_SUFFIX = REGEX_NEGATION_SUFFIX;
exports.REGEX_START = REGEX_START;
exports.RegExpUtils = RegExpUtils;
exports.SPECIAL_REGEX_SYMBOLS = SPECIAL_REGEX_SYMBOLS;
