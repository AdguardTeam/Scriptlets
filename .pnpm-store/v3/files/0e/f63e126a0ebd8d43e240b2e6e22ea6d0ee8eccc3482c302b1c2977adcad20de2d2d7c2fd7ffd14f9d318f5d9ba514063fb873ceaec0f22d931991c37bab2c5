{"version":3,"file":"jsdocUtils.cjs","names":["_getDefaultTagStructureForMode","_interopRequireDefault","require","_tagNames","_hasReturnValue","_WarnSettings","_jsdoccomment","e","__esModule","default","tagStructure","setTagStructure","mode","getDefaultTagStructureForMode","exports","flattenRoots","params","root","hasRestElement","hasPropertyRest","rests","names","reduce","acc","cur","Array","isArray","nms","flattened","inner","filter","Boolean","push","concat","isRestProperty","restElement","String","name","getPropertiesFromPropertySignature","propSignature","type","undefined","typeAnnotation","key","members","map","member","getFunctionParameterNames","functionNode","checkDefaultObjects","_functionNode$value","getParamName","param","isProperty","_param$left2","hasLeftTypeAnnotation","left","_typeAnnotation$typeA","propertyNames","annotationParamName","hasLeftName","_param$left","properties","roots","prop","value","elements","idx","right","raw","_param$left3","includes","_param$argument","argument","parameter","Error","hasParams","length","getJsdocTagsDeep","jsdoc","targetTagName","ret","tag","tags","entries","modeWarnSettings","WarnSettings","getTagNamesForMode","context","jsdocTags","typeScriptTags","closureTags","hasBeenWarned","report","loc","end","column","line","start","message","markSettingAsWarned","getTagDescription","tg","returnArray","descriptions","source","some","tokens","lineEnd","postDelimiter","postTag","description","desc","slice","join","getPreferredTagNameSimple","tagPreference","_Object$entries$find","prefValues","Object","values","prefVal","replacement","tagPreferenceFixed","fromEntries","replace","prototype","hasOwnProperty","call","tagNames","preferredTagName","find","aliases","isValidTag","definedTags","validTagNames","keys","flat","additionalTags","allTags","hasTag","targetTagLower","toLowerCase","doc","filterTags","getTags","tagName","item","getPreferredTagName","tagNamePreference","skipReportingBlockedTag","allowObjectReturn","defaultMessage","isObject","blocked","forEachPreferredTag","arrayHandler","matchingJsdocTags","matchingJsdocTag","getAllTags","inlineTags","inlineTag","flatMap","tagBegins","number","hasATag","targetTagNames","mayBeUndefinedTypeTag","tagType","trim","parsedTypes","tryParse","elem","ensureMap","has","set","Map","get","overrideTagStructure","structuredTags","tagMap","required","tagStruct","requiredName","requiredType","typeOrNameRequired","getTagStructureForMode","isNamepathDefiningTag","isNamepathReferencingTag","isNamepathOrUrlReferencingTag","tagMustHaveTypePosition","tagMightHaveTypePosition","namepathTypes","Set","tagMightHaveNamePosition","tagMightHaveNamepath","nampathRole","tagMustHaveNamePosition","tagMightHaveEitherTypeOrNamePosition","tagMustHaveEitherTypeOrNamePosition","tagMissingRequiredTypeOrNamepath","mustHaveTypePosition","mightHaveTypePosition","hasTypePosition","hasNameOrNamepathPosition","mustHaveEither","hasEither","hasNonFunctionYield","node","checkYieldReturnValue","body","bodyNode","arguments","element","expression","test","consequent","alternate","block","handler","finalizer","cases","someCase","nde","declarations","id","init","expressions","subExpression","property","computed","quasi","object","parent","hasYieldValue","generator","hasThrowValue","innerFunction","async","parseClosureTemplateTag","split","enforcedContexts","defaultContexts","settings","_context$options$","contexts","options","getContextObject","checkJsdoc","selInfo","lastIndex","selector","comment","bind","old","tagsWithNamesAndDescriptions","getTagsByType","tagsWithoutNames","tagsWithNames","tagWithName","getIndent","sourceCode","_sourceCode$text$matc","text","match","isConstructor","_node$parent","kind","isGetter","_node$parent2","isSetter","_node$parent3","hasAccessorPair","sourceKind","sourceName","oppositeKind","sibling","child","ky","exemptSpeciaMethods","schema","hasSchemaOption","_context$options$2","schemaProperties","checkGetters","checkSetters","dropPathSegmentQuotes","str","replaceAll","comparePaths","otherPathName","pathDoesNotBeginWith","startsWith","getRegexFromString","regexString","requiredFlags","flags","regex","uniqueFlags","RegExp"],"sources":["../src/jsdocUtils.js"],"sourcesContent":["import getDefaultTagStructureForMode from './getDefaultTagStructureForMode.js';\nimport {\n  closureTags,\n  jsdocTags,\n  typeScriptTags,\n} from './tagNames.js';\nimport {\n  hasReturnValue,\n  hasValueOrExecutorHasNonEmptyResolveValue,\n} from './utils/hasReturnValue.js';\nimport WarnSettings from './WarnSettings.js';\nimport {\n  tryParse,\n} from '@es-joy/jsdoccomment';\n\n/**\n * @typedef {number} Integer\n */\n/**\n * @typedef {import('./utils/hasReturnValue.js').ESTreeOrTypeScriptNode} ESTreeOrTypeScriptNode\n */\n\n/**\n * @typedef {\"jsdoc\"|\"typescript\"|\"closure\"|\"permissive\"} ParserMode\n */\n\n/**\n * @type {import('./getDefaultTagStructureForMode.js').TagStructure}\n */\nlet tagStructure;\n\n/**\n * @param {ParserMode} mode\n * @returns {void}\n */\nconst setTagStructure = (mode) => {\n  tagStructure = getDefaultTagStructureForMode(mode);\n};\n\n/**\n * @typedef {undefined|string|{\n *   name: Integer,\n *   restElement: boolean\n * }|{\n *   isRestProperty: boolean|undefined,\n *   name: string,\n *   restElement: boolean\n * }|{\n *   name: string,\n *   restElement: boolean\n * }} ParamCommon\n */\n/**\n * @typedef {ParamCommon|[string|undefined, (FlattendRootInfo & {\n *   annotationParamName?: string,\n * })]|NestedParamInfo} ParamNameInfo\n */\n\n/**\n * @typedef {{\n *   hasPropertyRest: boolean,\n *   hasRestElement: boolean,\n *   names: string[],\n *   rests: boolean[],\n * }} FlattendRootInfo\n */\n/**\n * @typedef {[string, (string[]|ParamInfo[])]} NestedParamInfo\n */\n/**\n * @typedef {ParamCommon|\n * [string|undefined, (FlattendRootInfo & {\n *   annotationParamName?: string\n * })]|\n * NestedParamInfo} ParamInfo\n */\n\n/**\n * Given a nested array of property names, reduce them to a single array,\n * appending the name of the root element along the way if present.\n * @callback FlattenRoots\n * @param {ParamInfo[]} params\n * @param {string} [root]\n * @returns {FlattendRootInfo}\n */\n\n/** @type {FlattenRoots} */\nconst flattenRoots = (params, root = '') => {\n  let hasRestElement = false;\n  let hasPropertyRest = false;\n\n  /**\n   * @type {boolean[]}\n   */\n  const rests = [];\n\n  const names = params.reduce(\n    /**\n     * @param {string[]} acc\n     * @param {ParamInfo} cur\n     * @returns {string[]}\n     */\n    (acc, cur) => {\n      if (Array.isArray(cur)) {\n        let nms;\n        if (Array.isArray(cur[1])) {\n          nms = cur[1];\n        } else {\n          if (cur[1].hasRestElement) {\n            hasRestElement = true;\n          }\n\n          if (cur[1].hasPropertyRest) {\n            hasPropertyRest = true;\n          }\n\n          nms = cur[1].names;\n        }\n\n        const flattened = flattenRoots(nms, root ? `${root}.${cur[0]}` : cur[0]);\n        if (flattened.hasRestElement) {\n          hasRestElement = true;\n        }\n\n        if (flattened.hasPropertyRest) {\n          hasPropertyRest = true;\n        }\n\n        const inner = /** @type {string[]} */ ([\n          root ? `${root}.${cur[0]}` : cur[0],\n          ...flattened.names,\n        ].filter(Boolean));\n        rests.push(false, ...flattened.rests);\n\n        return acc.concat(inner);\n      }\n\n      if (typeof cur === 'object') {\n        if ('isRestProperty' in cur && cur.isRestProperty) {\n          hasPropertyRest = true;\n          rests.push(true);\n        } else {\n          rests.push(false);\n        }\n\n        if ('restElement' in cur && cur.restElement) {\n          hasRestElement = true;\n        }\n\n        acc.push(root ? `${root}.${String(cur.name)}` : String(cur.name));\n      } else if (typeof cur !== 'undefined') {\n        rests.push(false);\n        acc.push(root ? `${root}.${cur}` : cur);\n      }\n\n      return acc;\n    }, [],\n  );\n\n  return {\n    hasPropertyRest,\n    hasRestElement,\n    names,\n    rests,\n  };\n};\n\n/**\n * @param {import('@typescript-eslint/types').TSESTree.TSIndexSignature|\n *  import('@typescript-eslint/types').TSESTree.TSConstructSignatureDeclaration|\n *  import('@typescript-eslint/types').TSESTree.TSCallSignatureDeclaration|\n *  import('@typescript-eslint/types').TSESTree.TSPropertySignature} propSignature\n * @returns {undefined|string|[string, string[]]}\n */\nconst getPropertiesFromPropertySignature = (propSignature) => {\n  if (\n    propSignature.type === 'TSIndexSignature' ||\n    propSignature.type === 'TSConstructSignatureDeclaration' ||\n    propSignature.type === 'TSCallSignatureDeclaration'\n  ) {\n    return undefined;\n  }\n\n  if (propSignature.typeAnnotation && propSignature.typeAnnotation.typeAnnotation.type === 'TSTypeLiteral') {\n    return [\n      /** @type {import('@typescript-eslint/types').TSESTree.Identifier} */ (\n        propSignature.key\n      ).name,\n      propSignature.typeAnnotation.typeAnnotation.members.map((member) => {\n        return /** @type {string} */ (\n          getPropertiesFromPropertySignature(\n            /** @type {import('@typescript-eslint/types').TSESTree.TSPropertySignature} */ (\n              member\n            ),\n          )\n        );\n      }),\n    ];\n  }\n\n  return /** @type {import('@typescript-eslint/types').TSESTree.Identifier} */ (\n    propSignature.key\n  ).name;\n};\n\n/**\n * @param {ESTreeOrTypeScriptNode|null} functionNode\n * @param {boolean} [checkDefaultObjects]\n * @throws {Error}\n * @returns {ParamNameInfo[]}\n */\nconst getFunctionParameterNames = (\n  functionNode, checkDefaultObjects,\n) => {\n  /* eslint-disable complexity -- Temporary */\n  /**\n   * @param {import('estree').Identifier|import('estree').AssignmentPattern|\n   *   import('estree').ObjectPattern|import('estree').Property|\n   *   import('estree').RestElement|import('estree').ArrayPattern|\n   *   import('@typescript-eslint/types').TSESTree.TSParameterProperty|\n   *   import('@typescript-eslint/types').TSESTree.Property|\n   *   import('@typescript-eslint/types').TSESTree.RestElement|\n   *   import('@typescript-eslint/types').TSESTree.Identifier|\n   *   import('@typescript-eslint/types').TSESTree.ObjectPattern|\n   *   import('@typescript-eslint/types').TSESTree.BindingName|\n   *   import('@typescript-eslint/types').TSESTree.Parameter\n   * } param\n   * @param {boolean} [isProperty]\n   * @returns {ParamNameInfo|[string, ParamNameInfo[]]}\n   */\n  const getParamName = (param, isProperty) => {\n    /* eslint-enable complexity -- Temporary */\n    const hasLeftTypeAnnotation = 'left' in param && 'typeAnnotation' in param.left;\n\n    if ('typeAnnotation' in param || hasLeftTypeAnnotation) {\n      const typeAnnotation = hasLeftTypeAnnotation ?\n        /** @type {import('@typescript-eslint/types').TSESTree.Identifier} */ (\n          param.left\n        ).typeAnnotation :\n        /** @type {import('@typescript-eslint/types').TSESTree.Identifier|import('@typescript-eslint/types').TSESTree.ObjectPattern} */\n        (param).typeAnnotation;\n\n      if (typeAnnotation?.typeAnnotation?.type === 'TSTypeLiteral') {\n        const propertyNames = typeAnnotation.typeAnnotation.members.map((member) => {\n          return getPropertiesFromPropertySignature(\n            /** @type {import('@typescript-eslint/types').TSESTree.TSPropertySignature} */\n            (member),\n          );\n        });\n\n        const flattened = {\n          ...flattenRoots(propertyNames),\n          annotationParamName: 'name' in param ? param.name : undefined,\n        };\n        const hasLeftName = 'left' in param && 'name' in param.left;\n\n        if ('name' in param || hasLeftName) {\n          return [\n            hasLeftName ?\n              /** @type {import('@typescript-eslint/types').TSESTree.Identifier} */ (\n                param.left\n              ).name :\n              /** @type {import('@typescript-eslint/types').TSESTree.Identifier} */ (\n                param\n              ).name,\n            flattened,\n          ];\n        }\n\n        return [\n          undefined, flattened,\n        ];\n      }\n    }\n\n    if ('name' in param) {\n      return param.name;\n    }\n\n    if ('left' in param && 'name' in param.left) {\n      return param.left.name;\n    }\n\n    if (\n      param.type === 'ObjectPattern' ||\n      ('left' in param &&\n      (\n        param\n      ).left.type === 'ObjectPattern')\n    ) {\n      const properties = /** @type {import('@typescript-eslint/types').TSESTree.ObjectPattern} */ (\n        param\n      ).properties ||\n        /** @type {import('estree').ObjectPattern} */\n        (\n          /** @type {import('@typescript-eslint/types').TSESTree.AssignmentPattern} */ (\n            param\n          ).left\n        )?.properties;\n      const roots = properties.map((prop) => {\n        return getParamName(prop, true);\n      });\n\n      return [\n        undefined, flattenRoots(roots),\n      ];\n    }\n\n    if (param.type === 'Property') {\n      switch (param.value.type) {\n      case 'ArrayPattern': {\n        return [\n          /** @type {import('estree').Identifier} */\n          (param.key).name,\n          /** @type {import('estree').ArrayPattern} */ (\n            param.value\n          ).elements.map((prop, idx) => {\n            return {\n              name: idx,\n              restElement: prop?.type === 'RestElement',\n            };\n          }),\n        ];\n      }\n\n      case 'ObjectPattern': {\n        return [\n          /** @type {import('estree').Identifier} */ (param.key).name,\n          /** @type {import('estree').ObjectPattern} */ (\n            param.value\n          ).properties.map((prop) => {\n            return /** @type {string|[string, string[]]} */ (getParamName(prop, isProperty));\n          }),\n        ];\n      }\n\n      case 'AssignmentPattern': {\n        switch (param.value.left.type) {\n        case 'Identifier':\n          // Default parameter\n          if (checkDefaultObjects && param.value.right.type === 'ObjectExpression') {\n            return [\n              /** @type {import('estree').Identifier} */ (\n                param.key\n              ).name,\n              /** @type {import('estree').AssignmentPattern} */ (\n                param.value\n              ).right.properties.map((prop) => {\n                return /** @type {string} */ (getParamName(\n                  /** @type {import('estree').Property} */\n                  (prop),\n                  isProperty,\n                ));\n              }),\n            ];\n          }\n\n          break;\n        case 'ObjectPattern':\n          return [\n            /** @type {import('estree').Identifier} */\n            (param.key).name,\n            /** @type {import('estree').ObjectPattern} */ (\n              param.value.left\n            ).properties.map((prop) => {\n              return getParamName(prop, isProperty);\n            }),\n          ];\n        case 'ArrayPattern':\n          return [\n            /** @type {import('estree').Identifier} */\n            (param.key).name,\n            /** @type {import('estree').ArrayPattern} */ (\n              param.value.left\n            ).elements.map((prop, idx) => {\n              return {\n                name: idx,\n                restElement: prop?.type === 'RestElement',\n              };\n            }),\n          ];\n        }\n      }\n      }\n\n      switch (param.key.type) {\n      case 'Identifier':\n        return param.key.name;\n\n      // The key of an object could also be a string or number\n      case 'Literal':\n        /* c8 ignore next 2 -- `raw` may not be present in all parsers */\n        return /** @type {string} */ (param.key.raw ||\n          param.key.value);\n\n      // case 'MemberExpression':\n      default:\n        // Todo: We should really create a structure (and a corresponding\n        //   option analogous to `checkRestProperty`) which allows for\n        //   (and optionally requires) dynamic properties to have a single\n        //   line of documentation\n        return undefined;\n      }\n    }\n\n    if (\n      param.type === 'ArrayPattern' ||\n      /** @type {import('estree').AssignmentPattern} */ (\n        param\n      ).left?.type === 'ArrayPattern'\n    ) {\n      const elements = /** @type {import('estree').ArrayPattern} */ (\n        param\n      ).elements || /** @type {import('estree').ArrayPattern} */ (\n        /** @type {import('estree').AssignmentPattern} */ (\n          param\n        ).left\n      )?.elements;\n      const roots = elements.map((prop, idx) => {\n        return {\n          name: `\"${idx}\"`,\n          restElement: prop?.type === 'RestElement',\n        };\n      });\n\n      return [\n        undefined, flattenRoots(roots),\n      ];\n    }\n\n    if ([\n      'RestElement', 'ExperimentalRestProperty',\n    ].includes(param.type)) {\n      return {\n        isRestProperty: isProperty,\n        name: /** @type {import('@typescript-eslint/types').TSESTree.Identifier} */ (\n          /** @type {import('@typescript-eslint/types').TSESTree.RestElement} */ (\n            param\n          // @ts-expect-error Ok\n          ).argument).name ?? param?.argument?.elements?.map(({name}) => {\n            return name;\n          }),\n        restElement: true,\n      };\n    }\n\n    if (param.type === 'TSParameterProperty') {\n      return getParamName(\n        /** @type {import('@typescript-eslint/types').TSESTree.Identifier} */ (\n          /** @type {import('@typescript-eslint/types').TSESTree.TSParameterProperty} */ (\n            param\n          ).parameter\n        ),\n        true,\n      );\n    }\n\n    throw new Error(`Unsupported function signature format: \\`${param.type}\\`.`);\n  };\n\n  if (!functionNode) {\n    return [];\n  }\n\n  return (/** @type {import('@typescript-eslint/types').TSESTree.FunctionDeclaration} */ (\n    functionNode\n  ).params || /** @type {import('@typescript-eslint/types').TSESTree.MethodDefinition} */ (\n    functionNode\n  ).value?.params || []).map((param) => {\n    return getParamName(param);\n  });\n};\n\n/**\n * @param {ESTreeOrTypeScriptNode} functionNode\n * @returns {Integer}\n */\nconst hasParams = (functionNode) => {\n  // Should also check `functionNode.value.params` if supporting `MethodDefinition`\n  return /** @type {import('@typescript-eslint/types').TSESTree.FunctionDeclaration} */ (\n    functionNode\n  ).params.length;\n};\n\n/**\n * Gets all names of the target type, including those that refer to a path, e.g.\n * `foo` or `foo.bar`.\n * @param {import('comment-parser').Block} jsdoc\n * @param {string} targetTagName\n * @returns {{\n *   idx: Integer,\n *   name: string,\n *   type: string\n * }[]}\n */\nconst getJsdocTagsDeep = (jsdoc, targetTagName) => {\n  const ret = [];\n  for (const [\n    idx,\n    {\n      name,\n      tag,\n      type,\n    },\n  ] of jsdoc.tags.entries()) {\n    if (tag !== targetTagName) {\n      continue;\n    }\n\n    ret.push({\n      idx,\n      name,\n      type,\n    });\n  }\n\n  return ret;\n};\n\nconst modeWarnSettings = WarnSettings();\n\n/**\n * @param {ParserMode|undefined} mode\n * @param {Reporter} context\n * @returns {import('./tagNames.js').AliasedTags}\n */\nconst getTagNamesForMode = (mode, context) => {\n  switch (mode) {\n  case 'jsdoc':\n    return jsdocTags;\n  case 'typescript':\n    return typeScriptTags;\n  case 'closure': case 'permissive':\n    return closureTags;\n  default:\n    if (!modeWarnSettings.hasBeenWarned(context, 'mode')) {\n      context.report({\n        loc: {\n          end: {\n            column: 1,\n            line: 1,\n          },\n          start: {\n            column: 1,\n            line: 1,\n          },\n        },\n        message: `Unrecognized value \\`${mode}\\` for \\`settings.jsdoc.mode\\`.`,\n      });\n      modeWarnSettings.markSettingAsWarned(context, 'mode');\n    }\n\n    // We'll avoid breaking too many other rules\n    return jsdocTags;\n  }\n};\n\n/**\n * @param {import('comment-parser').Spec} tg\n * @param {boolean} [returnArray]\n * @returns {string[]|string}\n */\nconst getTagDescription = (tg, returnArray) => {\n    /**\n     * @type {string[]}\n     */\n    const descriptions = [];\n    tg.source.some(({\n      tokens: {\n        end,\n        lineEnd,\n        postDelimiter,\n        tag,\n        postTag,\n        name,\n        type,\n        description,\n      },\n    }) => {\n      const desc = (\n        tag && postTag ||\n        !tag && !name && !type && postDelimiter || ''\n\n      // Remove space\n      ).slice(1) +\n        (description || '') + (lineEnd || '');\n\n      if (end) {\n        if (desc) {\n          descriptions.push(desc);\n        }\n\n        return true;\n      }\n\n      descriptions.push(desc);\n\n      return false;\n    });\n\n    return returnArray ? descriptions : descriptions.join('\\n');\n};\n\n/**\n * @typedef {{\n *   report: (descriptor: import('eslint').Rule.ReportDescriptor) => void\n * }} Reporter\n */\n\n/**\n * @param {string} name\n * @param {ParserMode|undefined} mode\n * @param {TagNamePreference} tagPreference\n * @param {Reporter} context\n * @returns {string|false|{\n *   message: string;\n *   replacement?: string|undefined;\n * }}\n */\nconst getPreferredTagNameSimple = (\n  name,\n  mode,\n  tagPreference = {},\n  context = {\n    report () {\n      // No-op\n    }\n  },\n) => {\n  const prefValues = Object.values(tagPreference);\n  if (prefValues.includes(name) || prefValues.some((prefVal) => {\n    return prefVal && typeof prefVal === 'object' && prefVal.replacement === name;\n  })) {\n    return name;\n  }\n\n  // Allow keys to have a 'tag ' prefix to avoid upstream bug in ESLint\n  // that disallows keys that conflict with Object.prototype,\n  // e.g. 'tag constructor' for 'constructor':\n  // https://github.com/eslint/eslint/issues/13289\n  // https://github.com/gajus/eslint-plugin-jsdoc/issues/537\n  const tagPreferenceFixed = Object.fromEntries(\n    Object\n      .entries(tagPreference)\n      .map(([\n        key,\n        value,\n      ]) => {\n        return [\n          key.replace(/^tag /u, ''), value,\n        ];\n      }),\n  );\n\n  if (Object.prototype.hasOwnProperty.call(tagPreferenceFixed, name)) {\n    return tagPreferenceFixed[name];\n  }\n\n  const tagNames = getTagNamesForMode(mode, context);\n\n  const preferredTagName = Object.entries(tagNames).find(([\n    , aliases,\n  ]) => {\n    return aliases.includes(name);\n  })?.[0];\n  if (preferredTagName) {\n    return preferredTagName;\n  }\n\n  return name;\n};\n\n/**\n * @param {import('eslint').Rule.RuleContext} context\n * @param {ParserMode|undefined} mode\n * @param {string} name\n * @param {string[]} definedTags\n * @returns {boolean}\n */\nconst isValidTag = (\n  context,\n  mode,\n  name,\n  definedTags,\n) => {\n  const tagNames = getTagNamesForMode(mode, context);\n\n  const validTagNames = Object.keys(tagNames).concat(Object.values(tagNames).flat());\n  const additionalTags = definedTags;\n  const allTags = validTagNames.concat(additionalTags);\n\n  return allTags.includes(name);\n};\n\n/**\n * @param {import('./iterateJsdoc.js').JsdocBlockWithInline} jsdoc\n * @param {string} targetTagName\n * @returns {boolean}\n */\nconst hasTag = (jsdoc, targetTagName) => {\n  const targetTagLower = targetTagName.toLowerCase();\n\n  return jsdoc.tags.some((doc) => {\n    return doc.tag.toLowerCase() === targetTagLower;\n  });\n};\n\n/**\n * @param {import('./iterateJsdoc.js').JsdocBlockWithInline} jsdoc\n * @param {(tag: import('@es-joy/jsdoccomment').JsdocTagWithInline) => boolean} filter\n * @returns {import('@es-joy/jsdoccomment').JsdocTagWithInline[]}\n */\nconst filterTags = (jsdoc, filter) => {\n  return jsdoc.tags.filter((tag) => {\n    return filter(tag);\n  });\n};\n\n/**\n * @param {import('./iterateJsdoc.js').JsdocBlockWithInline} jsdoc\n * @param {string} tagName\n * @returns {import('comment-parser').Spec[]}\n */\nconst getTags = (jsdoc, tagName) => {\n  return filterTags(jsdoc, (item) => {\n    return item.tag === tagName;\n  });\n};\n\n/**\n * @param {import('./iterateJsdoc.js').JsdocBlockWithInline} jsdoc\n * @param {{\n *   tagName: string,\n *   context?: import('eslint').Rule.RuleContext,\n *   mode?: ParserMode,\n *   report?: import('./iterateJsdoc.js').Report\n *   tagNamePreference?: TagNamePreference\n *   skipReportingBlockedTag?: boolean,\n *   allowObjectReturn?: boolean,\n *   defaultMessage?: string,\n * }} cfg\n * @returns {string|undefined|false|{\n *   message: string;\n *   replacement?: string|undefined;\n * }|{\n *   blocked: true,\n *   tagName: string\n * }}\n */\nconst getPreferredTagName = (jsdoc, {\n  tagName,\n  context, mode,\n  tagNamePreference,\n  report = () => {},\n  skipReportingBlockedTag = false,\n  allowObjectReturn = false,\n  defaultMessage = `Unexpected tag \\`@${tagName}\\``,\n}) => {\n  const ret = getPreferredTagNameSimple(tagName, mode, tagNamePreference, context);\n  const isObject = ret && typeof ret === 'object';\n  if (hasTag(jsdoc, tagName) && (ret === false || isObject && !ret.replacement)) {\n    if (skipReportingBlockedTag) {\n      return {\n        blocked: true,\n        tagName,\n      };\n    }\n\n    const message = isObject && ret.message || defaultMessage;\n    report(message, null, getTags(jsdoc, tagName)[0]);\n\n    return false;\n  }\n\n  return isObject && !allowObjectReturn ? ret.replacement : ret;\n};\n\n/**\n * @param {import('./iterateJsdoc.js').JsdocBlockWithInline} jsdoc\n * @param {string} tagName\n * @param {(\n *   matchingJsdocTag: import('@es-joy/jsdoccomment').JsdocTagWithInline,\n *   targetTagName: string\n * ) => void} arrayHandler\n * @param {object} cfg\n * @param {import('eslint').Rule.RuleContext} [cfg.context]\n * @param {ParserMode} [cfg.mode]\n * @param {import('./iterateJsdoc.js').Report} [cfg.report]\n * @param {TagNamePreference} [cfg.tagNamePreference]\n * @param {boolean} [cfg.skipReportingBlockedTag]\n * @returns {void}\n */\nconst forEachPreferredTag = (\n  jsdoc, tagName, arrayHandler,\n  {\n    context, mode, report,\n    tagNamePreference,\n    skipReportingBlockedTag = false,\n  } = {}\n) => {\n  const targetTagName = /** @type {string|false} */ (\n    getPreferredTagName(jsdoc, {\n      skipReportingBlockedTag,\n      tagName,\n      context, mode, report, tagNamePreference\n    })\n  );\n  if (!targetTagName ||\n    skipReportingBlockedTag && targetTagName && typeof targetTagName === 'object'\n  ) {\n    return;\n  }\n\n  const matchingJsdocTags = jsdoc.tags.filter(({\n    tag,\n  }) => {\n    return tag === targetTagName;\n  });\n\n  for (const matchingJsdocTag of matchingJsdocTags) {\n    arrayHandler(\n      /**\n       * @type {import('@es-joy/jsdoccomment').JsdocTagWithInline}\n       */ (\n        matchingJsdocTag\n      ), targetTagName,\n    );\n  }\n};\n\n/**\n * Get all tags, inline tags and inline tags in tags\n * @param {import('./iterateJsdoc.js').JsdocBlockWithInline} jsdoc\n * @returns {(import('comment-parser').Spec|\n *   import('@es-joy/jsdoccomment').JsdocInlineTagNoType)[]}\n */\nconst getAllTags = (jsdoc) => {\n  return [\n    ...jsdoc.tags,\n    ...jsdoc.inlineTags.map((inlineTag) => {\n      // Tags don't have source or line numbers, so add before returning\n      let line = -1;\n      for (const {\n        tokens: {\n          description,\n        },\n      } of jsdoc.source) {\n        line++;\n        if (description && description.includes(`{@${inlineTag.tag}`)) {\n          break;\n        }\n      }\n\n      inlineTag.line = line;\n\n      return inlineTag;\n    }),\n    ...jsdoc.tags.flatMap((tag) => {\n      let tagBegins = -1;\n      for (const {\n        tokens: {\n          tag: tg,\n        },\n      } of jsdoc.source) {\n        tagBegins++;\n        if (tg) {\n          break;\n        }\n      }\n\n      for (const inlineTag of tag.inlineTags) {\n        /** @type {import('./iterateJsdoc.js').Integer} */\n        let line = 0;\n        for (const {\n          number,\n          tokens: {\n            description,\n          },\n        } of tag.source) {\n          if (description && description.includes(`{@${inlineTag.tag}`)) {\n            line = number;\n            break;\n          }\n        }\n\n        inlineTag.line = tagBegins + line - 1;\n      }\n\n      return (\n        /**\n         * @type {import('comment-parser').Spec & {\n         *   inlineTags: import('@es-joy/jsdoccomment').JsdocInlineTagNoType[]\n         * }}\n         */ (\n          tag\n        ).inlineTags\n      );\n    }),\n  ];\n};\n\n/**\n * @param {import('./iterateJsdoc.js').JsdocBlockWithInline} jsdoc\n * @param {string[]} targetTagNames\n * @returns {boolean}\n */\nconst hasATag = (jsdoc, targetTagNames) => {\n  return targetTagNames.some((targetTagName) => {\n    return hasTag(jsdoc, targetTagName);\n  });\n};\n\n/**\n * Checks if the JSDoc comment has an undefined type.\n * @param {import('comment-parser').Spec|null|undefined} tag\n *   the tag which should be checked.\n * @param {ParserMode} mode\n * @returns {boolean}\n *   true in case a defined type is undeclared; otherwise false.\n */\nconst mayBeUndefinedTypeTag = (tag, mode) => {\n  // The function should not continue in the event the type is not defined...\n  if (typeof tag === 'undefined' || tag === null) {\n    return true;\n  }\n\n  // .. same applies if it declares an `{undefined}` or `{void}` type\n  const tagType = tag.type.trim();\n\n  // Exit early if matching\n  if (\n    tagType === 'undefined' || tagType === 'void' ||\n    tagType === '*' || tagType === 'any'\n  ) {\n    return true;\n  }\n\n  let parsedTypes;\n  try {\n    parsedTypes = tryParse(\n      tagType,\n      mode === 'permissive' ? undefined : [\n        mode,\n      ],\n    );\n  } catch {\n    // Ignore\n  }\n\n  if (\n    // We do not traverse deeply as it could be, e.g., `Promise<void>`\n    parsedTypes &&\n    parsedTypes.type === 'JsdocTypeUnion' &&\n    parsedTypes.elements.find((elem) => {\n      return elem.type === 'JsdocTypeUndefined' ||\n        elem.type === 'JsdocTypeName' && elem.value === 'void';\n    })) {\n    return true;\n  }\n\n  // In any other case, a type is present\n  return false;\n};\n\n/**\n * @param {import('./getDefaultTagStructureForMode.js').TagStructure} map\n * @param {string} tag\n * @returns {Map<string, string|string[]|boolean|undefined>}\n */\nconst ensureMap = (map, tag) => {\n  if (!map.has(tag)) {\n    map.set(tag, new Map());\n  }\n\n  return /** @type {Map<string, string | boolean>} */ (map.get(tag));\n};\n\n/**\n * @param {import('./iterateJsdoc.js').StructuredTags} structuredTags\n * @param {import('./getDefaultTagStructureForMode.js').TagStructure} tagMap\n * @returns {void}\n */\nconst overrideTagStructure = (structuredTags, tagMap = tagStructure) => {\n  for (const [\n    tag,\n    {\n      name,\n      type,\n      required = [],\n    },\n  ] of Object.entries(structuredTags)) {\n    const tagStruct = ensureMap(tagMap, tag);\n\n    tagStruct.set('namepathRole', name);\n    tagStruct.set('typeAllowed', type);\n\n    const requiredName = required.includes('name');\n    if (requiredName && name === false) {\n      throw new Error('Cannot add \"name\" to `require` with the tag\\'s `name` set to `false`');\n    }\n\n    tagStruct.set('nameRequired', requiredName);\n\n    const requiredType = required.includes('type');\n    if (requiredType && type === false) {\n      throw new Error('Cannot add \"type\" to `require` with the tag\\'s `type` set to `false`');\n    }\n\n    tagStruct.set('typeRequired', requiredType);\n\n    const typeOrNameRequired = required.includes('typeOrNameRequired');\n    if (typeOrNameRequired && name === false) {\n      throw new Error('Cannot add \"typeOrNameRequired\" to `require` with the tag\\'s `name` set to `false`');\n    }\n\n    if (typeOrNameRequired && type === false) {\n      throw new Error('Cannot add \"typeOrNameRequired\" to `require` with the tag\\'s `type` set to `false`');\n    }\n\n    tagStruct.set('typeOrNameRequired', typeOrNameRequired);\n  }\n};\n\n/**\n * @param {ParserMode} mode\n * @param {import('./iterateJsdoc.js').StructuredTags} structuredTags\n * @returns {import('./getDefaultTagStructureForMode.js').TagStructure}\n */\nconst getTagStructureForMode = (mode, structuredTags) => {\n  const tagStruct = getDefaultTagStructureForMode(mode);\n\n  try {\n    overrideTagStructure(structuredTags, tagStruct);\n  /* c8 ignore next 3 */\n  } catch {\n    //\n  }\n\n  return tagStruct;\n};\n\n/**\n * @param {string} tag\n * @param {import('./getDefaultTagStructureForMode.js').TagStructure} tagMap\n * @returns {boolean}\n */\nconst isNamepathDefiningTag = (tag, tagMap = tagStructure) => {\n  const tagStruct = ensureMap(tagMap, tag);\n\n  return tagStruct.get('namepathRole') === 'namepath-defining';\n};\n\n/**\n * @param {string} tag\n * @param {import('./getDefaultTagStructureForMode.js').TagStructure} tagMap\n * @returns {boolean}\n */\nconst isNamepathReferencingTag = (tag, tagMap = tagStructure) => {\n  const tagStruct = ensureMap(tagMap, tag);\n  return tagStruct.get('namepathRole') === 'namepath-referencing';\n};\n\n/**\n * @param {string} tag\n * @param {import('./getDefaultTagStructureForMode.js').TagStructure} tagMap\n * @returns {boolean}\n */\nconst isNamepathOrUrlReferencingTag = (tag, tagMap = tagStructure) => {\n  const tagStruct = ensureMap(tagMap, tag);\n  return tagStruct.get('namepathRole') === 'namepath-or-url-referencing';\n};\n\n/**\n * @param {string} tag\n * @param {import('./getDefaultTagStructureForMode.js').TagStructure} tagMap\n * @returns {boolean|undefined}\n */\nconst tagMustHaveTypePosition = (tag, tagMap = tagStructure) => {\n  const tagStruct = ensureMap(tagMap, tag);\n\n  return /** @type {boolean|undefined} */ (tagStruct.get('typeRequired'));\n};\n\n/**\n * @param {string} tag\n * @param {import('./getDefaultTagStructureForMode.js').TagStructure} tagMap\n * @returns {boolean|string}\n */\nconst tagMightHaveTypePosition = (tag, tagMap = tagStructure) => {\n  if (tagMustHaveTypePosition(tag, tagMap)) {\n    return true;\n  }\n\n  const tagStruct = ensureMap(tagMap, tag);\n\n  const ret = /** @type {boolean|undefined} */ (tagStruct.get('typeAllowed'));\n\n  return ret === undefined ? true : ret;\n};\n\nconst namepathTypes = new Set([\n  'namepath-defining', 'namepath-referencing',\n]);\n\n/**\n * @param {string} tag\n * @param {import('./getDefaultTagStructureForMode.js').TagStructure} tagMap\n * @returns {boolean}\n */\nconst tagMightHaveNamePosition = (tag, tagMap = tagStructure) => {\n  const tagStruct = ensureMap(tagMap, tag);\n\n  const ret = tagStruct.get('namepathRole');\n\n  return ret === undefined ? true : Boolean(ret);\n};\n\n/**\n * @param {string} tag\n * @param {import('./getDefaultTagStructureForMode.js').TagStructure} tagMap\n * @returns {boolean}\n */\nconst tagMightHaveNamepath = (tag, tagMap = tagStructure) => {\n  const tagStruct = ensureMap(tagMap, tag);\n\n  const nampathRole = tagStruct.get('namepathRole');\n\n  return nampathRole !== false &&\n    namepathTypes.has(/** @type {string} */ (nampathRole));\n};\n\n/**\n * @param {string} tag\n * @param {import('./getDefaultTagStructureForMode.js').TagStructure} tagMap\n * @returns {boolean|undefined}\n */\nconst tagMustHaveNamePosition = (tag, tagMap = tagStructure) => {\n  const tagStruct = ensureMap(tagMap, tag);\n\n  return /** @type {boolean|undefined} */ (tagStruct.get('nameRequired'));\n};\n\n/**\n * @param {string} tag\n * @param {import('./getDefaultTagStructureForMode.js').TagStructure} tagMap\n * @returns {boolean}\n */\nconst tagMightHaveEitherTypeOrNamePosition = (tag, tagMap) => {\n  return Boolean(tagMightHaveTypePosition(tag, tagMap)) || tagMightHaveNamepath(tag, tagMap);\n};\n\n/**\n * @param {string} tag\n * @param {import('./getDefaultTagStructureForMode.js').TagStructure} tagMap\n * @returns {boolean|undefined}\n */\nconst tagMustHaveEitherTypeOrNamePosition = (tag, tagMap) => {\n  const tagStruct = ensureMap(tagMap, tag);\n\n  return /** @type {boolean} */ (tagStruct.get('typeOrNameRequired'));\n};\n\n/**\n * @param {import('comment-parser').Spec} tag\n * @param {import('./getDefaultTagStructureForMode.js').TagStructure} tagMap\n * @returns {boolean|undefined}\n */\nconst tagMissingRequiredTypeOrNamepath = (tag, tagMap = tagStructure) => {\n  const mustHaveTypePosition = tagMustHaveTypePosition(tag.tag, tagMap);\n  const mightHaveTypePosition = tagMightHaveTypePosition(tag.tag, tagMap);\n  const hasTypePosition = mightHaveTypePosition && Boolean(tag.type);\n  const hasNameOrNamepathPosition = (\n    tagMustHaveNamePosition(tag.tag, tagMap) ||\n    tagMightHaveNamepath(tag.tag, tagMap)\n  ) && Boolean(tag.name);\n  const mustHaveEither = tagMustHaveEitherTypeOrNamePosition(tag.tag, tagMap);\n  const hasEither = tagMightHaveEitherTypeOrNamePosition(tag.tag, tagMap) &&\n    (hasTypePosition || hasNameOrNamepathPosition);\n\n  return mustHaveEither && !hasEither && !mustHaveTypePosition;\n};\n\n/* eslint-disable complexity -- Temporary */\n/**\n * @param {ESTreeOrTypeScriptNode|null|undefined} node\n * @param {boolean} [checkYieldReturnValue]\n * @returns {boolean}\n */\nconst hasNonFunctionYield = (node, checkYieldReturnValue) => {\n  /* eslint-enable complexity -- Temporary */\n  if (!node) {\n    return false;\n  }\n\n  switch (node.type) {\n  case 'BlockStatement': {\n    return node.body.some((bodyNode) => {\n      return ![\n        'ArrowFunctionExpression',\n        'FunctionDeclaration',\n        'FunctionExpression',\n      ].includes(bodyNode.type) && hasNonFunctionYield(\n        bodyNode, checkYieldReturnValue,\n      );\n    });\n  }\n\n  /* c8 ignore next 2 -- In Babel? */\n  // @ts-expect-error In Babel?\n  case 'OptionalCallExpression':\n  case 'CallExpression':\n    return node.arguments.some((element) => {\n      return hasNonFunctionYield(element, checkYieldReturnValue);\n    });\n  case 'ChainExpression':\n  case 'ExpressionStatement': {\n    return hasNonFunctionYield(node.expression, checkYieldReturnValue);\n  }\n\n  case 'LabeledStatement':\n  case 'WhileStatement':\n  case 'DoWhileStatement':\n  case 'ForStatement':\n  case 'ForInStatement':\n  case 'ForOfStatement':\n  case 'WithStatement': {\n    return hasNonFunctionYield(node.body, checkYieldReturnValue);\n  }\n\n  case 'ConditionalExpression':\n  case 'IfStatement': {\n    return hasNonFunctionYield(node.test, checkYieldReturnValue) ||\n      hasNonFunctionYield(node.consequent, checkYieldReturnValue) ||\n      hasNonFunctionYield(node.alternate, checkYieldReturnValue);\n  }\n\n  case 'TryStatement': {\n    return hasNonFunctionYield(node.block, checkYieldReturnValue) ||\n      hasNonFunctionYield(\n        node.handler && node.handler.body, checkYieldReturnValue,\n      ) ||\n      hasNonFunctionYield(\n        /** @type {import('@typescript-eslint/types').TSESTree.BlockStatement} */\n        (node.finalizer),\n        checkYieldReturnValue,\n      );\n  }\n\n  case 'SwitchStatement': {\n    return node.cases.some(\n      (someCase) => {\n        return someCase.consequent.some((nde) => {\n          return hasNonFunctionYield(nde, checkYieldReturnValue);\n        });\n      },\n    );\n  }\n\n  case 'ArrayPattern':\n  case 'ArrayExpression':\n    return node.elements.some((element) => {\n      return hasNonFunctionYield(element, checkYieldReturnValue);\n    });\n  case 'AssignmentPattern':\n    return hasNonFunctionYield(node.right, checkYieldReturnValue);\n\n  case 'VariableDeclaration': {\n    return node.declarations.some((nde) => {\n      return hasNonFunctionYield(nde, checkYieldReturnValue);\n    });\n  }\n\n  case 'VariableDeclarator': {\n    return hasNonFunctionYield(node.id, checkYieldReturnValue) ||\n      hasNonFunctionYield(node.init, checkYieldReturnValue);\n  }\n\n  case 'AssignmentExpression':\n  case 'BinaryExpression':\n  case 'LogicalExpression': {\n    return hasNonFunctionYield(node.left, checkYieldReturnValue) ||\n      hasNonFunctionYield(node.right, checkYieldReturnValue);\n  }\n\n  // Comma\n  case 'SequenceExpression':\n  case 'TemplateLiteral':\n    return node.expressions.some((subExpression) => {\n      return hasNonFunctionYield(subExpression, checkYieldReturnValue);\n    });\n\n  case 'ObjectPattern':\n  case 'ObjectExpression':\n    return node.properties.some((property) => {\n      return hasNonFunctionYield(property, checkYieldReturnValue);\n    });\n\n  /* c8 ignore next -- In Babel? */\n  case 'PropertyDefinition':\n  /* eslint-disable no-fallthrough */\n  /* c8 ignore next 2 -- In Babel? */\n  // @ts-expect-error In Babel?\n  case 'ObjectProperty':\n  /* c8 ignore next 2 -- In Babel? */\n  // @ts-expect-error In Babel?\n  case 'ClassProperty':\n  case 'Property':\n  /* eslint-enable no-fallthrough */\n    return node.computed && hasNonFunctionYield(node.key, checkYieldReturnValue) ||\n      hasNonFunctionYield(node.value, checkYieldReturnValue);\n  /* c8 ignore next 2 -- In Babel? */\n  // @ts-expect-error In Babel?\n  case 'ObjectMethod':\n    /* c8 ignore next 6 -- In Babel? */\n    // @ts-expect-error In Babel?\n    return node.computed && hasNonFunctionYield(node.key, checkYieldReturnValue) ||\n      // @ts-expect-error In Babel?\n      node.arguments.some((nde) => {\n        return hasNonFunctionYield(nde, checkYieldReturnValue);\n      });\n\n  case 'SpreadElement':\n  case 'UnaryExpression':\n    return hasNonFunctionYield(node.argument, checkYieldReturnValue);\n\n  case 'TaggedTemplateExpression':\n    return hasNonFunctionYield(node.quasi, checkYieldReturnValue);\n\n  // ?.\n  /* c8 ignore next 2 -- In Babel? */\n  // @ts-expect-error In Babel?\n  case 'OptionalMemberExpression':\n  case 'MemberExpression':\n    return hasNonFunctionYield(node.object, checkYieldReturnValue) ||\n      hasNonFunctionYield(node.property, checkYieldReturnValue);\n\n  /* c8 ignore next 2 -- In Babel? */\n  // @ts-expect-error In Babel?\n  case 'Import':\n  case 'ImportExpression':\n    return hasNonFunctionYield(node.source, checkYieldReturnValue);\n\n  case 'ReturnStatement': {\n    if (node.argument === null) {\n      return false;\n    }\n\n    return hasNonFunctionYield(node.argument, checkYieldReturnValue);\n  }\n\n  case 'YieldExpression': {\n    if (checkYieldReturnValue) {\n      if (\n        /** @type {import('eslint').Rule.Node} */ (\n          node\n        ).parent.type === 'VariableDeclarator'\n      ) {\n        return true;\n      }\n\n      return false;\n    }\n\n    // void return does not count.\n    if (node.argument === null) {\n      return false;\n    }\n\n    return true;\n  }\n\n  default: {\n    return false;\n  }\n  }\n};\n\n/**\n * Checks if a node has a return statement. Void return does not count.\n * @param {ESTreeOrTypeScriptNode} node\n * @param {boolean} [checkYieldReturnValue]\n * @returns {boolean}\n */\nconst hasYieldValue = (node, checkYieldReturnValue) => {\n  return /** @type {import('@typescript-eslint/types').TSESTree.FunctionDeclaration} */ (\n    node\n  ).generator && (\n    /** @type {import('@typescript-eslint/types').TSESTree.FunctionDeclaration} */ (\n      node\n    ).expression || hasNonFunctionYield(\n      /** @type {import('@typescript-eslint/types').TSESTree.FunctionDeclaration} */\n      (node).body,\n      checkYieldReturnValue,\n    )\n  );\n};\n\n/**\n * Checks if a node has a throws statement.\n * @param {ESTreeOrTypeScriptNode|null|undefined} node\n * @param {boolean} [innerFunction]\n * @returns {boolean}\n */\n// eslint-disable-next-line complexity\nconst hasThrowValue = (node, innerFunction) => {\n  if (!node) {\n    return false;\n  }\n\n  // There are cases where a function may execute its inner function which\n  //   throws, but we're treating functions atomically rather than trying to\n  //   follow them\n  switch (node.type) {\n  case 'FunctionExpression':\n  case 'FunctionDeclaration':\n  case 'ArrowFunctionExpression': {\n    return !innerFunction && !node.async && hasThrowValue(node.body, true);\n  }\n\n  case 'BlockStatement': {\n    return node.body.some((bodyNode) => {\n      return bodyNode.type !== 'FunctionDeclaration' && hasThrowValue(bodyNode);\n    });\n  }\n\n  case 'LabeledStatement':\n  case 'WhileStatement':\n  case 'DoWhileStatement':\n  case 'ForStatement':\n  case 'ForInStatement':\n  case 'ForOfStatement':\n  case 'WithStatement': {\n    return hasThrowValue(node.body);\n  }\n\n  case 'IfStatement': {\n    return hasThrowValue(node.consequent) || hasThrowValue(node.alternate);\n  }\n\n  // We only consider it to throw an error if the catch or finally blocks throw an error.\n  case 'TryStatement': {\n    return hasThrowValue(node.handler && node.handler.body) ||\n        hasThrowValue(node.finalizer);\n  }\n\n  case 'SwitchStatement': {\n    return node.cases.some(\n      (someCase) => {\n        return someCase.consequent.some((nde) => {\n          return hasThrowValue(nde);\n        });\n      },\n    );\n  }\n\n  case 'ThrowStatement': {\n    return true;\n  }\n\n  default: {\n    return false;\n  }\n  }\n};\n\n/**\n * @param {string} tag\n */\n/*\nconst isInlineTag = (tag) => {\n  return /^(@link|@linkcode|@linkplain|@tutorial) /u.test(tag);\n};\n*/\n\n/**\n * Parses GCC Generic/Template types\n * @see {@link https://github.com/google/closure-compiler/wiki/Generic-Types}\n * @see {@link https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#template}\n * @param {import('comment-parser').Spec} tag\n * @returns {string[]}\n */\nconst parseClosureTemplateTag = (tag) => {\n  return tag.name\n    .split(',')\n    .map((type) => {\n      return type.trim().replace(/^\\[(?<name>.*?)=.*\\]$/u, '$<name>');\n    });\n};\n\n/**\n * @typedef {true|string[]} DefaultContexts\n */\n\n/**\n * Checks user option for `contexts` array, defaulting to\n * contexts designated by the rule. Returns an array of\n * ESTree AST types, indicating allowable contexts.\n * @param {import('eslint').Rule.RuleContext} context\n * @param {DefaultContexts|undefined} defaultContexts\n * @param {{\n *   contexts?: import('./iterateJsdoc.js').Context[]\n * }} settings\n * @returns {(string|import('./iterateJsdoc.js').ContextObject)[]}\n */\nconst enforcedContexts = (context, defaultContexts, settings) => {\n  const contexts = context.options[0]?.contexts || settings.contexts || (defaultContexts === true ? [\n    'ArrowFunctionExpression',\n    'FunctionDeclaration',\n    'FunctionExpression',\n    'TSDeclareFunction',\n  ] : defaultContexts);\n\n  return contexts;\n};\n\n/**\n * @param {import('./iterateJsdoc.js').Context[]} contexts\n * @param {import('./iterateJsdoc.js').CheckJsdoc} checkJsdoc\n * @param {import('@es-joy/jsdoccomment').CommentHandler} [handler]\n * @returns {import('eslint').Rule.RuleListener}\n */\nconst getContextObject = (contexts, checkJsdoc, handler) => {\n  /** @type {import('eslint').Rule.RuleListener} */\n  const properties = {};\n\n  for (const [\n    idx,\n    prop,\n  ] of contexts.entries()) {\n    /** @type {string} */\n    let property;\n\n    /** @type {(node: import('eslint').Rule.Node) => void} */\n    let value;\n\n    if (typeof prop === 'object') {\n      const selInfo = {\n        lastIndex: idx,\n        selector: prop.context,\n      };\n      if (prop.comment) {\n        property = /** @type {string} */ (prop.context);\n        value = checkJsdoc.bind(\n          null,\n          {\n            ...selInfo,\n            comment: prop.comment,\n          },\n          /**\n           * @type {(jsdoc: import('@es-joy/jsdoccomment').JsdocBlockWithInline) => boolean}\n           */\n          (/** @type {import('@es-joy/jsdoccomment').CommentHandler} */ (\n            handler\n          ).bind(null, prop.comment)),\n        );\n      } else {\n        property = /** @type {string} */ (prop.context);\n        value = checkJsdoc.bind(null, selInfo, null);\n      }\n    } else {\n      const selInfo = {\n        lastIndex: idx,\n        selector: prop,\n      };\n      property = prop;\n      value = checkJsdoc.bind(null, selInfo, null);\n    }\n\n    const old = /**\n                 * @type {((node: import('eslint').Rule.Node) => void)}\n                 */ (properties[property]);\n    properties[property] = old ?\n      /**\n       * @type {((node: import('eslint').Rule.Node) => void)}\n       */\n      function (node) {\n        old(node);\n        value(node);\n      } :\n      value;\n  }\n\n  return properties;\n};\n\nconst tagsWithNamesAndDescriptions = new Set([\n  'param', 'arg', 'argument', 'property', 'prop',\n  'template',\n\n  // These two are parsed by our custom parser as though having a `name`\n  'returns', 'return',\n]);\n\n/**\n * @typedef {{\n *   [key: string]: false|string|\n *     {message: string, replacement?: string}\n * }} TagNamePreference\n */\n\n/**\n * @param {import('eslint').Rule.RuleContext} context\n * @param {ParserMode|undefined} mode\n * @param {import('comment-parser').Spec[]} tags\n * @returns {{\n *   tagsWithNames: import('comment-parser').Spec[],\n *   tagsWithoutNames: import('comment-parser').Spec[]\n * }}\n */\nconst getTagsByType = (context, mode, tags) => {\n  /**\n   * @type {import('comment-parser').Spec[]}\n   */\n  const tagsWithoutNames = [];\n  const tagsWithNames = tags.filter((tag) => {\n    const {\n      tag: tagName,\n    } = tag;\n    const tagWithName = tagsWithNamesAndDescriptions.has(tagName);\n    if (!tagWithName) {\n      tagsWithoutNames.push(tag);\n    }\n\n    return tagWithName;\n  });\n\n  return {\n    tagsWithNames,\n    tagsWithoutNames,\n  };\n};\n\n/**\n * @param {import('eslint').SourceCode|{\n *   text: string\n * }} sourceCode\n * @returns {string}\n */\nconst getIndent = (sourceCode) => {\n  return (sourceCode.text.match(/^\\n*([ \\t]+)/u)?.[1] ?? '') + ' ';\n};\n\n/**\n * @param {import('eslint').Rule.Node|null} node\n * @returns {boolean}\n */\nconst isConstructor = (node) => {\n  return node?.type === 'MethodDefinition' && node.kind === 'constructor' ||\n  /** @type {import('@typescript-eslint/types').TSESTree.MethodDefinition} */ (\n    node?.parent\n  )?.kind === 'constructor';\n};\n\n/**\n * @param {import('eslint').Rule.Node|null} node\n * @returns {boolean}\n */\nconst isGetter = (node) => {\n  return node !== null &&\n  /**\n   * @type {import('@typescript-eslint/types').TSESTree.MethodDefinition|\n   *   import('@typescript-eslint/types').TSESTree.Property}\n   */ (\n    node.parent\n  )?.kind === 'get';\n};\n\n/**\n * @param {import('eslint').Rule.Node|null} node\n * @returns {boolean}\n */\nconst isSetter = (node) => {\n  return node !== null &&\n  /**\n   * @type {import('@typescript-eslint/types').TSESTree.MethodDefinition|\n   *   import('@typescript-eslint/types').TSESTree.Property}\n   */(\n    node.parent\n  )?.kind === 'set';\n};\n\n/**\n * @param {import('eslint').Rule.Node} node\n * @returns {boolean}\n */\nconst hasAccessorPair = (node) => {\n  const {\n    type,\n    kind: sourceKind,\n    key,\n  } =\n    /**\n     * @type {import('@typescript-eslint/types').TSESTree.MethodDefinition|\n     *   import('@typescript-eslint/types').TSESTree.Property}\n     */ (node);\n\n  const sourceName =\n    /** @type {import('@typescript-eslint/types').TSESTree.Identifier} */ (\n      key\n    ).name;\n\n  const oppositeKind = sourceKind === 'get' ? 'set' : 'get';\n\n  const sibling = type === 'MethodDefinition' ?\n    /** @type {import('@typescript-eslint/types').TSESTree.ClassBody} */ (\n      node.parent\n    ).body :\n    /** @type {import('@typescript-eslint/types').TSESTree.ObjectExpression} */ (\n      node.parent\n    ).properties;\n\n  return (\n    sibling.some((child) => {\n      const {\n        kind,\n        key: ky,\n      } = /**\n           * @type {import('@typescript-eslint/types').TSESTree.MethodDefinition|\n           *   import('@typescript-eslint/types').TSESTree.Property}\n           */ (child);\n\n      const name =\n        /** @type {import('@typescript-eslint/types').TSESTree.Identifier} */ (\n          ky\n        ).name;\n\n      return kind === oppositeKind && name === sourceName;\n    })\n  );\n};\n\n/**\n * @param {import('./iterateJsdoc.js').JsdocBlockWithInline} jsdoc\n * @param {import('eslint').Rule.Node|null} node\n * @param {import('eslint').Rule.RuleContext} context\n * @param {import('json-schema').JSONSchema4} schema\n * @returns {boolean}\n */\nconst exemptSpeciaMethods = (jsdoc, node, context, schema) => {\n  /**\n   * @param {\"checkGetters\"|\"checkSetters\"|\"checkConstructors\"} prop\n   * @returns {boolean|\"no-setter\"|\"no-getter\"}\n   */\n  const hasSchemaOption = (prop) => {\n    const schemaProperties = schema[0].properties;\n\n    return context.options[0]?.[prop] ??\n      (schemaProperties[prop] && schemaProperties[prop].default);\n  };\n\n  const checkGetters = hasSchemaOption('checkGetters');\n  const checkSetters = hasSchemaOption('checkSetters');\n\n  return !hasSchemaOption('checkConstructors') &&\n    (\n      isConstructor(node) ||\n      hasATag(jsdoc, [\n        'class',\n        'constructor',\n      ])) ||\n  isGetter(node) && (\n    !checkGetters ||\n    checkGetters === 'no-setter' && hasAccessorPair(/** @type {import('./iterateJsdoc.js').Node} */ (node).parent)\n  ) ||\n  isSetter(node) && (\n    !checkSetters ||\n    checkSetters === 'no-getter' && hasAccessorPair(/** @type {import('./iterateJsdoc.js').Node} */ (node).parent)\n  );\n};\n\n/**\n * Since path segments may be unquoted (if matching a reserved word,\n * identifier or numeric literal) or single or double quoted, in either\n * the `@param` or in source, we need to strip the quotes to give a fair\n * comparison.\n * @param {string} str\n * @returns {string}\n */\nconst dropPathSegmentQuotes = (str) => {\n  return str.replaceAll(/\\.(['\"])(.*)\\1/gu, '.$2');\n};\n\n/**\n * @param {string} name\n * @returns {(otherPathName: string) => boolean}\n */\nconst comparePaths = (name) => {\n  return (otherPathName) => {\n    return otherPathName === name ||\n      dropPathSegmentQuotes(otherPathName) === dropPathSegmentQuotes(name);\n  };\n};\n\n/**\n * @callback PathDoesNotBeginWith\n * @param {string} name\n * @param {string} otherPathName\n * @returns {boolean}\n */\n\n/** @type {PathDoesNotBeginWith} */\nconst pathDoesNotBeginWith = (name, otherPathName) => {\n  return !name.startsWith(otherPathName) &&\n    !dropPathSegmentQuotes(name).startsWith(dropPathSegmentQuotes(otherPathName));\n};\n\n/**\n * @param {string} regexString\n * @param {string} [requiredFlags]\n * @returns {RegExp}\n */\nconst getRegexFromString = (regexString, requiredFlags) => {\n  const match = regexString.match(/^\\/(.*)\\/([gimyus]*)$/us);\n  let flags = 'u';\n  let regex = regexString;\n  if (match) {\n    [\n      , regex,\n      flags,\n    ] = match;\n    if (!flags) {\n      flags = 'u';\n    }\n  }\n\n  const uniqueFlags = [\n    ...new Set(flags + (requiredFlags || '')),\n  ];\n  flags = uniqueFlags.join('');\n\n  return new RegExp(regex, flags);\n};\n\nexport {\n  comparePaths,\n  dropPathSegmentQuotes,\n  enforcedContexts,\n  exemptSpeciaMethods,\n  filterTags,\n  flattenRoots,\n  forEachPreferredTag,\n  getAllTags,\n  getContextObject,\n  getFunctionParameterNames,\n  getIndent,\n  getJsdocTagsDeep,\n  getPreferredTagName,\n  getPreferredTagNameSimple,\n  getRegexFromString,\n  getTagDescription,\n  getTags,\n  getTagsByType,\n  getTagStructureForMode,\n  hasATag,\n  hasParams,\n  hasReturnValue,\n  hasTag,\n  hasThrowValue,\n  hasValueOrExecutorHasNonEmptyResolveValue,\n  hasYieldValue,\n  isConstructor,\n  isGetter,\n  isNamepathDefiningTag,\n  isNamepathOrUrlReferencingTag,\n  isNamepathReferencingTag,\n  isSetter,\n  isValidTag,\n  mayBeUndefinedTypeTag,\n  overrideTagStructure,\n  parseClosureTemplateTag,\n  pathDoesNotBeginWith,\n  setTagStructure,\n  tagMightHaveEitherTypeOrNamePosition,\n  tagMightHaveNamepath,\n  tagMightHaveNamePosition,\n  tagMightHaveTypePosition,\n  tagMissingRequiredTypeOrNamepath,\n  tagMustHaveNamePosition,\n  tagMustHaveTypePosition,\n};\n"],"mappings":"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","ignoreList":[]}