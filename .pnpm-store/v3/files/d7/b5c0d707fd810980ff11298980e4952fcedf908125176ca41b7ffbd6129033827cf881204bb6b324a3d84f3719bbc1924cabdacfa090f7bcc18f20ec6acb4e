/*
 * AGTree v3.0.0-alpha.1 (build date: Tue, 12 Nov 2024 16:11:58 GMT)
 * (c) 2024 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
'use strict';

var zod = require('zod');
var XRegExp = require('xregexp');
var zodCamelcase = require('../utils/zod-camelcase.js');
var base = require('./base.js');
var error = require('../../utils/error.js');

/**
 * @file Schema for modifier data.
 */
/**
 * Known validators that don't need to be validated as regex.
 */
const KNOWN_VALIDATORS = new Set([
    'domain',
    'pipe_separated_domains',
    'regexp',
    'url',
]);
/**
 * Zod schema for modifier data.
 */
zodCamelcase.zodToCamelCase(base.baseCompatibilityDataSchema.extend({
    /**
     * List of modifiers that are incompatible with the actual one.
     */
    conflicts: zod.array(base.nonEmptyStringSchema).nullable().default(null),
    /**
     * The actual modifier is incompatible with all other modifiers, except the ones listed in `conflicts`.
     */
    inverse_conflicts: base.booleanSchema.default(false),
    /**
     * Describes whether the actual modifier supports value assignment. For example, `$domain` is assignable,
     * so it can be used like this: `$domain=domain.com\|~subdomain.domain.com`, where `=` is the assignment operator
     * and `domain.com\|~subdomain.domain.com` is the value.
     */
    assignable: base.booleanSchema.default(false),
    /**
     * Describes whether the actual modifier can be negated. For example, `$third-party` is negatable,
     * so it can be used like this: `$~third-party`.
     */
    negatable: base.booleanSchema.default(true),
    /**
     * The actual modifier can only be used in blocking rules, it cannot be used in exceptions.
     * If it's value is `true`, then the modifier can be used only in blocking rules.
     * `exception_only` and `block_only` cannot be used together (they are mutually exclusive).
     */
    block_only: base.booleanSchema.default(false),
    /**
     * The actual modifier can only be used in exceptions, it cannot be used in blocking rules.
     * If it's value is `true`, then the modifier can be used only in exceptions.
     * `exception_only` and `block_only` cannot be used together (they are mutually exclusive).
     */
    exception_only: base.booleanSchema.default(false),
    /**
     * Describes whether the *assignable* modifier value is required.
     * For example, `$cookie` is assignable but it can be used without a value in exception rules:
     * `@@\|\|example.com^$cookie`.
     * If `false`, the `value_format` is required, e.g. the value of `$app` should always be specified
     */
    value_optional: base.booleanSchema.default(false),
    /**
     * Describes the format of the value for the *assignable* modifier.
     * Its value can be a regex pattern or a known validator name (e.g. `domain`, `pipe_separated_domains`, etc.).
     */
    value_format: base.nonEmptyStringSchema.nullable().default(null),
}).superRefine((data, ctx) => {
    // TODO: find something better, for now we can't add refine logic to the base schema:
    // https://github.com/colinhacks/zod/issues/454#issuecomment-848370721
    base.baseRefineLogic(data, ctx);
    if (data.block_only && data.exception_only) {
        ctx.addIssue({
            code: zod.ZodIssueCode.custom,
            message: 'block_only and exception_only are mutually exclusive',
        });
    }
    if (data.assignable && !data.value_format) {
        ctx.addIssue({
            code: zod.ZodIssueCode.custom,
            message: 'value_format is required for assignable modifiers',
        });
    }
    if (data.value_format) {
        const valueFormat = data.value_format.trim();
        // if it is a known validator, we don't need to validate it further
        if (KNOWN_VALIDATORS.has(valueFormat)) {
            return;
        }
        // otherwise, we need to validate it as a regex
        try {
            XRegExp(valueFormat);
        }
        catch (error$1) {
            ctx.addIssue({
                code: zod.ZodIssueCode.custom,
                message: error.getErrorMessage(error$1),
            });
        }
    }
}));
