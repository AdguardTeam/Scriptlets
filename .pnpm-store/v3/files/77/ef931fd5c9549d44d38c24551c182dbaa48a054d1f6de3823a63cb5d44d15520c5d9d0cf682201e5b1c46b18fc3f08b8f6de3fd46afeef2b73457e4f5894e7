/*
 * AGTree v3.0.0-alpha.1 (build date: Tue, 12 Nov 2024 16:11:58 GMT)
 * (c) 2024 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
'use strict';

var adblockers = require('../../utils/adblockers.js');
var string = require('../../utils/string.js');
var modifierList = require('../misc/modifier-list.js');
var constants = require('../../utils/constants.js');
var index = require('../../nodes/index.js');
var adblockSyntaxError = require('../../errors/adblock-syntax-error.js');
var options = require('../options.js');
var baseParser = require('../base-parser.js');
var valueParser = require('../misc/value-parser.js');

/**
 * `NetworkRuleParser` is responsible for parsing network rules.
 *
 * Please note that this will parse all syntactically correct network rules.
 * Modifier compatibility is not checked at the parser level.
 *
 * @see {@link https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#basic-rules}
 * @see {@link https://help.eyeo.com/adblockplus/how-to-write-filters#basic}
 */
class NetworkRuleParser extends baseParser.BaseParser {
    /**
     * Parses a network rule (also known as basic rule).
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Network rule AST
     *
     * @throws If the rule is syntactically incorrect.
     */
    static parse(raw, options$1 = options.defaultParserOptions, baseOffset = 0) {
        let offset = 0;
        // Skip leading whitespace
        offset = string.StringUtils.skipWS(raw, offset);
        // Handle exception rules
        let exception = false;
        // Rule starts with exception marker, eg @@||example.com,
        // where @@ is the exception marker
        if (raw.startsWith(constants.NETWORK_RULE_EXCEPTION_MARKER, offset)) {
            offset += constants.NETWORK_RULE_EXCEPTION_MARKER_LEN;
            exception = true;
        }
        // Save the start of the pattern
        const patternStart = offset;
        // Find corresponding (last) separator ($) character (if any)
        const separatorIndex = NetworkRuleParser.findNetworkRuleSeparatorIndex(raw);
        // Save the end of the pattern
        const patternEnd = separatorIndex === -1
            ? string.StringUtils.skipWSBack(raw) + 1
            : string.StringUtils.skipWSBack(raw, separatorIndex - 1) + 1;
        // Parse pattern
        const pattern = valueParser.ValueParser.parse(raw.slice(patternStart, patternEnd), options$1, baseOffset + patternStart);
        // Parse modifiers (if any)
        let modifiers;
        // Find start and end index of the modifiers
        const modifiersStart = separatorIndex + 1;
        const modifiersEnd = string.StringUtils.skipWSBack(raw) + 1;
        if (separatorIndex !== -1) {
            modifiers = modifierList.ModifierListParser.parse(raw.slice(modifiersStart, modifiersEnd), options$1, baseOffset + modifiersStart);
        }
        // Throw error if there is no pattern and no modifiers
        if (pattern.value.length === 0 && (modifiers === undefined || modifiers.children.length === 0)) {
            throw new adblockSyntaxError.AdblockSyntaxError('Network rule must have a pattern or modifiers', baseOffset, baseOffset + raw.length);
        }
        const result = {
            type: index.NetworkRuleType.NetworkRule,
            category: index.RuleCategory.Network,
            syntax: adblockers.AdblockSyntax.Common,
            exception,
            pattern,
            modifiers,
        };
        if (options$1.includeRaws) {
            result.raws = {
                text: raw,
            };
        }
        if (options$1.isLocIncluded) {
            result.start = baseOffset;
            result.end = baseOffset + raw.length;
        }
        return result;
    }
    /**
     * Finds the index of the separator character in a network rule.
     *
     * @param rule Network rule to check
     * @returns The index of the separator character, or -1 if there is no separator
     */
    static findNetworkRuleSeparatorIndex(rule) {
        // As we are looking for the last separator, we start from the end of the string
        for (let i = rule.length - 1; i >= 0; i -= 1) {
            // If we find a potential separator, we should check
            // - if it's not escaped
            // - if it's not followed by a regex marker, for example: `example.org^$removeparam=/regex$/`
            // eslint-disable-next-line max-len
            if (rule[i] === constants.NETWORK_RULE_SEPARATOR && rule[i + 1] !== constants.REGEX_MARKER && rule[i - 1] !== constants.ESCAPE_CHARACTER) {
                return i;
            }
        }
        return -1;
    }
}

exports.NetworkRuleParser = NetworkRuleParser;
