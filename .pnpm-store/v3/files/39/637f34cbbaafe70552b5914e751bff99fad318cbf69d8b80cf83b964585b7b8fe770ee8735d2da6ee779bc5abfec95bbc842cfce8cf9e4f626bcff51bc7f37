/*
 * AGTree v3.0.0-alpha.1 (build date: Tue, 12 Nov 2024 16:11:58 GMT)
 * (c) 2024 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
'use strict';

var string = require('../../utils/string.js');
var adblockers = require('../../utils/adblockers.js');
var constants = require('../../utils/constants.js');
var index = require('../../nodes/index.js');
var options = require('../options.js');
var baseParser = require('../base-parser.js');
var valueParser = require('../misc/value-parser.js');

/**
 * @file Metadata comments
 */
/**
 * Value map for binary deserialization. This helps to reduce the size of the serialized data,
 * as it allows us to use a single byte to represent frequently used values.
 */
const KNOWN_METADATA_HEADERS = new Set([
    'Checksum',
    'Description',
    'Expires',
    'Homepage',
    'Last Modified',
    'LastModified',
    'Licence',
    'License',
    'Time Updated',
    'TimeUpdated',
    'Version',
    'Title',
]);
/**
 * `MetadataParser` is responsible for parsing metadata comments.
 * Metadata comments are special comments that specify some properties of the list.
 *
 * @example
 * For example, in the case of
 * ```adblock
 * ! Title: My List
 * ```
 * the name of the header is `Title`, and the value is `My List`, which means that
 * the list title is `My List`, and it can be used in the adblocker UI.
 * @see {@link https://help.eyeo.com/adblockplus/how-to-write-filters#special-comments}
 */
class MetadataCommentParser extends baseParser.BaseParser {
    /**
     * Parses a raw rule as a metadata comment.
     *
     * @param raw Raw input to parse.
     * @param options Global parser options.
     * @param baseOffset Starting offset of the input. Node locations are calculated relative to this offset.
     * @returns Metadata comment AST or null (if the raw rule cannot be parsed as a metadata comment)
     */
    static parse(raw, options$1 = options.defaultParserOptions, baseOffset = 0) {
        // Fast check to avoid unnecessary work
        if (raw.indexOf(constants.COLON) === -1) {
            return null;
        }
        let offset = 0;
        // Skip leading spaces before the comment marker
        offset = string.StringUtils.skipWS(raw, offset);
        // Check if the rule starts with a comment marker (first non-space sequence)
        if (raw[offset] !== index.CommentMarker.Regular && raw[offset] !== index.CommentMarker.Hashmark) {
            return null;
        }
        // Consume the comment marker
        const marker = valueParser.ValueParser.parse(raw[offset], options$1, baseOffset + offset);
        offset += 1;
        // Skip spaces
        offset = string.StringUtils.skipWS(raw, offset);
        // Save header start position
        const headerStart = offset;
        // Check if the comment text starts with a known header
        const text = raw.slice(offset);
        for (const knownHeader of KNOWN_METADATA_HEADERS) {
            // Check if the comment text starts with the header (case-insensitive)
            if (text.toLocaleLowerCase().startsWith(knownHeader.toLocaleLowerCase())) {
                // Skip the header
                offset += knownHeader.length;
                // Save header
                const header = valueParser.ValueParser.parse(raw.slice(headerStart, offset), options$1, baseOffset + headerStart);
                // Skip spaces after the header
                offset = string.StringUtils.skipWS(raw, offset);
                // Check if the rule contains a separator after the header
                if (raw[offset] !== constants.COLON) {
                    return null;
                }
                // Skip the separator
                offset += 1;
                // Skip spaces after the separator
                offset = string.StringUtils.skipWS(raw, offset);
                // Save the value start position
                const valueStart = offset;
                // Check if the rule contains a value
                if (offset >= raw.length) {
                    return null;
                }
                const valueEnd = string.StringUtils.skipWSBack(raw, raw.length - 1) + 1;
                // Save the value
                const value = valueParser.ValueParser.parse(raw.slice(valueStart, valueEnd), options$1, baseOffset + valueStart);
                const result = {
                    type: index.CommentRuleType.MetadataCommentRule,
                    category: index.RuleCategory.Comment,
                    syntax: adblockers.AdblockSyntax.Common,
                    marker,
                    header,
                    value,
                };
                if (options$1.includeRaws) {
                    result.raws = {
                        text: raw,
                    };
                }
                if (options$1.isLocIncluded) {
                    result.start = baseOffset;
                    result.end = baseOffset + raw.length;
                }
                return result;
            }
        }
        return null;
    }
}

exports.MetadataCommentParser = MetadataCommentParser;
