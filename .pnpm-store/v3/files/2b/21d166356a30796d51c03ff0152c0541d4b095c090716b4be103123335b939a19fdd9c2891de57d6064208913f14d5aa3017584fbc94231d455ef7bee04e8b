/*
 * AGTree v3.0.0-alpha.1 (build date: Tue, 12 Nov 2024 16:11:58 GMT)
 * (c) 2024 Adguard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/tsurlfilter/tree/master/packages/agtree#readme
 */
'use strict';

var constants = require('./constants.js');

/**
 * @file Utility functions for working with quotes
 */
/**
 * Set of all possible quote characters supported by the library
 */
const QUOTE_SET = new Set([
    constants.SINGLE_QUOTE,
    constants.DOUBLE_QUOTE,
    constants.BACKTICK_QUOTE,
]);
/**
 * Possible quote types for scriptlet parameters
 */
exports.QuoteType = void 0;
(function (QuoteType) {
    /**
     * No quotes at all
     */
    QuoteType["None"] = "none";
    /**
     * Single quotes (`'`)
     */
    QuoteType["Single"] = "single";
    /**
     * Double quotes (`"`)
     */
    QuoteType["Double"] = "double";
    /**
     * Backtick quotes (`` ` ``)
     */
    QuoteType["Backtick"] = "backtick";
})(exports.QuoteType || (exports.QuoteType = {}));
/**
 * Utility functions for working with quotes
 */
class QuoteUtils {
    /**
     * Escape all unescaped occurrences of the character
     *
     * @param string String to escape
     * @param char Character to escape
     * @returns Escaped string
     */
    static escapeUnescapedOccurrences(string, char) {
        let result = constants.EMPTY;
        for (let i = 0; i < string.length; i += 1) {
            if (string[i] === char && (i === 0 || string[i - 1] !== constants.ESCAPE_CHARACTER)) {
                result += constants.ESCAPE_CHARACTER;
            }
            result += string[i];
        }
        return result;
    }
    /**
     * Unescape all single escaped occurrences of the character
     *
     * @param string String to unescape
     * @param char Character to unescape
     * @returns Unescaped string
     */
    static unescapeSingleEscapedOccurrences(string, char) {
        let result = constants.EMPTY;
        for (let i = 0; i < string.length; i += 1) {
            if (string[i] === char
                && string[i - 1] === constants.ESCAPE_CHARACTER
                && (i === 1 || string[i - 2] !== constants.ESCAPE_CHARACTER)) {
                result = result.slice(0, -1);
            }
            result += string[i];
        }
        return result;
    }
    /**
     * Get quote type of the string
     *
     * @param string String to check
     * @returns Quote type of the string
     */
    static getStringQuoteType(string) {
        // Don't check 1-character strings to avoid false positives
        if (string.length > 1) {
            if (string.startsWith(constants.SINGLE_QUOTE) && string.endsWith(constants.SINGLE_QUOTE)) {
                return exports.QuoteType.Single;
            }
            if (string.startsWith(constants.DOUBLE_QUOTE) && string.endsWith(constants.DOUBLE_QUOTE)) {
                return exports.QuoteType.Double;
            }
            if (string.startsWith(constants.BACKTICK_QUOTE) && string.endsWith(constants.BACKTICK_QUOTE)) {
                return exports.QuoteType.Backtick;
            }
        }
        return exports.QuoteType.None;
    }
    /**
     * Set quote type of the string
     *
     * @param string String to set quote type of
     * @param quoteType Quote type to set
     * @returns String with the specified quote type
     */
    static setStringQuoteType(string, quoteType) {
        const actualQuoteType = QuoteUtils.getStringQuoteType(string);
        switch (quoteType) {
            case exports.QuoteType.None:
                if (actualQuoteType === exports.QuoteType.Single) {
                    return QuoteUtils.escapeUnescapedOccurrences(string.slice(1, -1), constants.SINGLE_QUOTE);
                }
                if (actualQuoteType === exports.QuoteType.Double) {
                    return QuoteUtils.escapeUnescapedOccurrences(string.slice(1, -1), constants.DOUBLE_QUOTE);
                }
                if (actualQuoteType === exports.QuoteType.Backtick) {
                    return QuoteUtils.escapeUnescapedOccurrences(string.slice(1, -1), constants.BACKTICK_QUOTE);
                }
                return string;
            case exports.QuoteType.Single:
                if (actualQuoteType === exports.QuoteType.None) {
                    return constants.SINGLE_QUOTE + QuoteUtils.escapeUnescapedOccurrences(string, constants.SINGLE_QUOTE) + constants.SINGLE_QUOTE;
                }
                if (actualQuoteType === exports.QuoteType.Double) {
                    return constants.SINGLE_QUOTE
                        + QuoteUtils.escapeUnescapedOccurrences(QuoteUtils.unescapeSingleEscapedOccurrences(string.slice(1, -1), constants.DOUBLE_QUOTE), constants.SINGLE_QUOTE) + constants.SINGLE_QUOTE;
                }
                if (actualQuoteType === exports.QuoteType.Backtick) {
                    return constants.SINGLE_QUOTE
                        + QuoteUtils.escapeUnescapedOccurrences(QuoteUtils.unescapeSingleEscapedOccurrences(string.slice(1, -1), constants.BACKTICK_QUOTE), constants.SINGLE_QUOTE) + constants.SINGLE_QUOTE;
                }
                return string;
            case exports.QuoteType.Double:
                if (actualQuoteType === exports.QuoteType.None) {
                    return constants.DOUBLE_QUOTE + QuoteUtils.escapeUnescapedOccurrences(string, constants.DOUBLE_QUOTE) + constants.DOUBLE_QUOTE;
                }
                if (actualQuoteType !== exports.QuoteType.Double) {
                    // eslint-disable-next-line max-len
                    return constants.DOUBLE_QUOTE
                        + QuoteUtils.escapeUnescapedOccurrences(QuoteUtils.unescapeSingleEscapedOccurrences(string.slice(1, -1), constants.SINGLE_QUOTE), constants.DOUBLE_QUOTE) + constants.DOUBLE_QUOTE;
                }
                return string;
            case exports.QuoteType.Backtick:
                if (actualQuoteType === exports.QuoteType.None) {
                    // eslint-disable-next-line max-len
                    return constants.BACKTICK_QUOTE + QuoteUtils.escapeUnescapedOccurrences(string, constants.BACKTICK_QUOTE) + constants.BACKTICK_QUOTE;
                }
                if (actualQuoteType !== exports.QuoteType.Backtick) {
                    // eslint-disable-next-line max-len
                    return constants.BACKTICK_QUOTE
                        + QuoteUtils.escapeUnescapedOccurrences(QuoteUtils.unescapeSingleEscapedOccurrences(string.slice(1, -1), constants.SINGLE_QUOTE), constants.BACKTICK_QUOTE) + constants.BACKTICK_QUOTE;
                }
                return string;
            default:
                return string;
        }
    }
    /**
     * Removes bounding quotes from a string, if any
     *
     * @param string Input string
     * @returns String without quotes
     */
    static removeQuotes(string) {
        if (
        // We should check for string length to avoid false positives
        string.length > 1
            && (string[0] === constants.SINGLE_QUOTE || string[0] === constants.DOUBLE_QUOTE || string[0] === constants.BACKTICK_QUOTE)
            && string[0] === string[string.length - 1]) {
            return string.slice(1, -1);
        }
        return string;
    }
    /**
     * Removes bounding quotes from a string, if any, and unescapes the escaped quotes,
     * like transforming `'abc\'def'` to `abc'def`.
     *
     * @param string Input string
     * @returns String without quotes
     */
    static removeQuotesAndUnescape(string) {
        if (
        // We should check for string length to avoid false positives
        string.length > 1
            && (string[0] === constants.SINGLE_QUOTE || string[0] === constants.DOUBLE_QUOTE || string[0] === constants.BACKTICK_QUOTE)
            && string[0] === string[string.length - 1]) {
            return QuoteUtils.unescapeSingleEscapedOccurrences(string.slice(1, -1), string[0]);
        }
        return string;
    }
    /**
     * Wraps given `strings` with `quote` (defaults to single quote `'`)
     * and joins them with `separator` (defaults to comma+space `, `).
     *
     * @param strings Strings to quote and join.
     * @param quoteType Quote to use.
     * @param separator Separator to use.
     *
     * @returns String with joined items.
     *
     * @example
     * ['abc', 'def']: strings[]  ->  "'abc', 'def'": string
     */
    static quoteAndJoinStrings(strings, quoteType = exports.QuoteType.Single, separator = `${constants.COMMA}${constants.SPACE}`) {
        return strings
            .map((s) => QuoteUtils.setStringQuoteType(s, quoteType))
            .join(separator);
    }
}

exports.QUOTE_SET = QUOTE_SET;
exports.QuoteUtils = QuoteUtils;
